<!DOCTYPE html>
<!-- _layouts/distill.html --><html>
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">    <!-- Metadata, OpenGraph and Schema.org -->
    

    <!-- Standard metadata -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Introduction to rustworkx | Soon  Teh</title>
    <meta name="author" content="Soon  Teh">
    <meta name="description" content="With examples and applications in quantum computing">


    <!-- Bootstrap & MDB -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous">

    <!-- Bootstrap Table -->
    <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.css">

    <!-- Fonts & Icons -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous">
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons">

    <!-- Code Syntax Highlighting -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light">

    

    <!-- Styles -->
    
    <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;">
    
    <link rel="stylesheet" href="/assets/css/main.css">
    <link rel="canonical" href="https://soon-teh.github.io/blog/2023/intro-to-rustworkx/">

    <!-- Dark Mode -->
    


    <!-- jQuery -->
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>

    <!-- MathJax -->
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        tags: 'ams'
      }
    };
  </script>
  <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script>
  <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>

    <!-- Distill js -->
    <script src="/assets/js/distillpub/template.v2.js"></script>
    <script src="/assets/js/distillpub/transforms.v2.js"></script>
    <script src="/assets/js/distillpub/overrides.js"></script>
    
    <!-- Page/Post style -->
    <style type="text/css">
      .post-img {
  max-height: 80vh;
  max-width: 100%;
}

    </style>
  </head>

  <body>
<d-front-matter>
    <script async type="text/json">{
      "title": "Introduction to rustworkx",
      "description": "With examples and applications in quantum computing",
      "published": "June 7, 2023",
      "authors": [
        {
          "author": "Soon Teh",
          "authorURL": "",
          "affiliations": [
            {
              "name": "EQuIP, OIST",
              "url": ""
            }
          ]
        }
        
      ],
      "katex": {
        "delimiters": [
          {
            "left": "$",
            "right": "$",
            "display": false
          },
          {
            "left": "$$",
            "right": "$$",
            "display": true
          }
        ]
      }
    }</script>
  </d-front-matter>

  

    <!-- Header -->
    <header>

      <!-- Nav Bar -->
      <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top">
        <div class="container">
          <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Soon </span>Teh</a>
          <!-- Navbar Toggle -->
          <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar top-bar"></span>
            <span class="icon-bar middle-bar"></span>
            <span class="icon-bar bottom-bar"></span>
          </button>

          <div class="collapse navbar-collapse text-right" id="navbarNav">
            <ul class="navbar-nav ml-auto flex-nowrap">

              <!-- About -->
              <li class="nav-item ">
                <a class="nav-link" href="/">about</a>
              </li>
              
              <!-- Blog -->
              <li class="nav-item active">
                <a class="nav-link" href="/blog/">blog<span class="sr-only">(current)</span></a>
              </li>

              <!-- Other pages -->
              <li class="nav-item ">
                <a class="nav-link" href="/publications/">publications</a>
              </li>
              <li class="nav-item ">
                <a class="nav-link" href="/teaching/">teaching</a>
              </li>
            </ul>
          </div>
        </div>
      </nav>

      <!-- Scrolling Progress Bar -->
      <progress id="progress" value="0">
        <div class="progress-container">
          <span class="progress-bar"></span>
        </div>
      </progress>
    </header>


    <!-- Content -->
    <div class="post distill">

      <d-title>
        <h1>Introduction to rustworkx</h1>
        <p>With examples and applications in quantum computing</p>
      </d-title>

      <d-byline></d-byline>

      <d-article>
        <d-contents>
          <nav class="l-text figcaption">
          <h3>Contents</h3>
            <div><a href="#rustworkx">rustworkx</a></div>
            <div><a href="#ibm-hardware-coupling-map">IBM Hardware Coupling Map</a></div>
            <ul>
              <li><a href="#visualization">Visualization</a></li>
              <li><a href="#betweenness-centrality">Betweenness Centrality</a></li>
              <li><a href="#distance-matrix">Distance Matrix</a></li>
              <li><a href="#transversal">Transversal</a></li>
              
            </ul>
<div><a href="#map-coloring-and-efficient-quantum-measurement">Map Coloring and Efficient Quantum Measurement</a></div>
            <ul>
              <li><a href="#four-color-theorem">Four-Color Theorem</a></li>
              <li><a href="#pauli-grouping">Pauli Grouping</a></li>
              
            </ul>
<div><a href="#final-remarks">Final Remarks</a></div>
            
          </nav>
        </d-contents>

        <h2 id="rustworkx">rustworkx</h2>
<p>Qiskit uses <a href="https://github.com/Qiskit/rustworkx" rel="external nofollow noopener" target="_blank"><strong>rustworkx</strong></a> (or formerly <strong>retworkx</strong>), a graph library under the hood. rustworkx was originally conceived to build a faster directed acyclic graph (DAG) to use as the underlying data structure for qiskit-terra’s transpiler. For instance, a Bell state circuit can be represented as a directed graph as follows:</p>

<p><img class="mx-auto d-block mb-2 post-img" src="/assets/img/2023-06-07/bell.png"><br></p>

<p>Prior to rustworkx, qiskit uses <a href="https://networkx.org/" rel="external nofollow noopener" target="_blank"><strong>NetworkX</strong></a>. NetworkX’s pure Python implementation leads to a performance bottleneck, and thus rustworkx addressed this by implementing the graph data structures and algorithms in Rust. The performance gain was documented to be 3x to 100x for the same use case compared to NetworkX.<d-cite key="Treinish_2022"></d-cite></p>

<p>Despite basing on NetworkX, rustworkx is not a drop-in replacement, and some of its implementations varies. Key differences and conversion guide can be found <a href="https://qiskit.org/documentation/retworkx/networkx.html" rel="external nofollow noopener" target="_blank">here</a>. This blog post will be looking at some of rustworkx’s features and application of a graph algorithm in quantum computing.</p>

<h2 id="ibm-hardware-coupling-map">IBM Hardware Coupling Map</h2>
<p>This section will use IBM’s hardware coupling map as an example to demonstrate some of rustworkx’s features. The coupling map is a graph that represents the connectivity of the qubits in a quantum device. First, the coupling map is loaded from IBM’s hardware backend:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">qiskit.providers.fake_provider</span> <span class="kn">import</span> <span class="n">FakeAuckland</span>

<span class="n">backend</span> <span class="o">=</span> <span class="nc">FakeAuckland</span><span class="p">()</span>
<span class="n">backend</span><span class="p">.</span><span class="n">coupling_map</span><span class="p">.</span><span class="nf">draw</span><span class="p">()</span>
</code></pre></div></div>
<p><img class="mx-auto d-block mb-2 post-img" src="/assets/img/2023-06-07/auckland-graph.png"><br></p>

<p>The circles in the diagram is a <em>node</em> that represents a physical qubit on the device and the arrows are <em>edges</em> that represent the connectivity between the qubits. Each arrow has a <em>weight</em> that is determined by its corresponding CNOT gate error rate.</p>

<p><img class="mx-auto d-block mb-2 post-img" src="/assets/img/2023-06-07/auckland-error.png"><br></p>

<p>The standard graph algorithms perform summation across the edges of non-negative weights. Thus, the weights $w$ are defined as the negative log of the CNOT gate success rate:</p>

\[w_{ij}=-\log(1-p_{ij})\]

<p>where $p_{ij}$ is the CNOT gate error rate for the control qubit $i$ and target qubit $j$. Under this convention, smaller weights correspond to higher success probability. For simplicity, the coupling map will be converted to an undirected graph because of the symmetry of the CNOT gate error rate for <code class="language-plaintext highlighter-rouge">ibm_auckland</code>. Special care taking into consideration of the gate asymmetry is needed for hardware such as the <a href="https://research.ibm.com/blog/eagle-quantum-error-mitigation" rel="external nofollow noopener" target="_blank">Eagle processor</a>, which utilizes uni-directional echoed cross-resonance (ECR) gates.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="n">rustworkx</span> <span class="k">as</span> <span class="n">rx</span>

<span class="c1"># extract the two-qubit error rate from the backend
</span><span class="n">two_q_error_map</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">gate</span><span class="p">,</span> <span class="n">prop_dict</span> <span class="ow">in</span> <span class="n">backend</span><span class="p">.</span><span class="n">target</span><span class="p">.</span><span class="nf">items</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">qargs</span><span class="p">,</span> <span class="n">inst_props</span> <span class="ow">in</span> <span class="n">prop_dict</span><span class="p">.</span><span class="nf">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">qargs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">inst_props</span><span class="p">.</span><span class="n">error</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">two_q_error_map</span><span class="p">[</span><span class="n">qargs</span><span class="p">]</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span>
                    <span class="n">two_q_error_map</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">qargs</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">inst_props</span><span class="p">.</span><span class="n">error</span>
                <span class="p">)</span>

<span class="c1"># convert two-qubit error rate to edge weight
</span><span class="n">two_q_suc</span> <span class="o">=</span> <span class="mi">1</span><span class="o">-</span><span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="n">two_q_error_map</span><span class="p">.</span><span class="nf">values</span><span class="p">()))</span>
<span class="n">neg_log_two_q_suc_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="n">two_q_suc</span><span class="p">)</span>
<span class="n">neg_log_two_q_suc</span> <span class="o">=</span> <span class="nf">dict</span><span class="p">(</span><span class="nf">zip</span><span class="p">(</span><span class="n">two_q_error_map</span><span class="p">.</span><span class="nf">keys</span><span class="p">(),</span> <span class="n">neg_log_two_q_suc_val</span><span class="p">))</span>

<span class="c1"># create undirected graph
</span><span class="n">g</span> <span class="o">=</span> <span class="n">rx</span><span class="p">.</span><span class="nc">PyGraph</span><span class="p">(</span><span class="n">multigraph</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="n">g</span><span class="p">.</span><span class="nf">extend_from_weighted_edge_list</span><span class="p">([(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="nf">for </span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">neg_log_two_q_suc</span><span class="p">.</span><span class="nf">items</span><span class="p">()])</span>
</code></pre></div></div>

<p>An empty undirected graph <code class="language-plaintext highlighter-rouge">PyGraph</code> object was first created and populated with the weighted edges using <code class="language-plaintext highlighter-rouge">extend_from_weighted_edge_list</code>. This method will create the nodes and edges if they do not exist. The <code class="language-plaintext highlighter-rouge">multigraph=False</code> argument ensures that the undirected graph has no parallel edges.</p>

<h3 id="visualization">Visualization</h3>
<p>Similar to NetworkX and other popular graph packages, the generated graphs can be visualized using Matplotlib. Under rustworkx, this is done using the <code class="language-plaintext highlighter-rouge">mpl_draw</code> function.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">rustworkx.visualization</span> <span class="kn">import</span> <span class="n">graphviz_draw</span><span class="p">,</span> <span class="n">mpl_draw</span>

<span class="nf">mpl_draw</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
</code></pre></div></div>

<p><img class="mx-auto d-block mb-2 post-img" src="/assets/img/2023-06-07/mpl.png"><br></p>

<p>As readers may notice, using Matplotlib to visualize complex graphs can be quite cluttered. Instead, using an alternative method <code class="language-plaintext highlighter-rouge">graphviz_draw</code> with Graphviz to render the graph can improve the clarity and visibility of the components. <a href="https://graphviz.org" rel="external nofollow noopener" target="_blank">Graphviz</a> is a dedicated graph visualization software that supports detailed customization of graph styling.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">graphviz_draw</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="sh">'</span><span class="s">neato</span><span class="sh">'</span><span class="p">)</span>
</code></pre></div></div>

<p><img class="mx-auto d-block mb-2 post-img" src="/assets/img/2023-06-07/neato.png"><br></p>

<h3 id="betweenness-centrality">Betweenness Centrality</h3>
<p>Given the coupling map graph, it may be helpful to identify a vital node (qubit) in the graph. Centralities are measures of the relative importance of a node in a graph. One such measure is the betweenness centrality, where for each node $v$ is metric is proportional to the number of shortest paths between all pairs of nodes $\sigma(s,t)$ that passes through $v$:</p>

\[c_B(v)=\sum_{s,t \in V}\frac{\sigma(s,t|v)}{\sigma(s,t)}\]

<p>This is available in rustworkx 0.13.0 as <code class="language-plaintext highlighter-rouge">betweenness_centrality</code> for only unweighted graph:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">matplotlib</span>

<span class="c1"># Assigning data payload to color nodes with graphviz_draw
</span><span class="k">for</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">btw</span> <span class="ow">in</span> <span class="n">c_degree</span><span class="p">.</span><span class="nf">items</span><span class="p">():</span>
    <span class="n">g</span><span class="p">[</span><span class="n">node_id</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">node_id</span><span class="p">,</span> <span class="n">btw</span><span class="p">)</span>

<span class="c1"># Leverage matplotlib for color map
</span><span class="n">colormap</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="p">.</span><span class="n">colormaps</span><span class="p">[</span><span class="sh">"</span><span class="s">magma</span><span class="sh">"</span><span class="p">]</span>
<span class="n">norm</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="p">.</span><span class="n">colors</span><span class="p">.</span><span class="nc">Normalize</span><span class="p">(</span>
    <span class="n">vmin</span><span class="o">=</span><span class="nf">min</span><span class="p">(</span><span class="n">c_degree</span><span class="p">.</span><span class="nf">values</span><span class="p">()),</span>
    <span class="n">vmax</span><span class="o">=</span><span class="nf">max</span><span class="p">(</span><span class="n">c_degree</span><span class="p">.</span><span class="nf">values</span><span class="p">())</span><span class="o">*</span><span class="mf">1.2</span>
<span class="p">)</span>

<span class="k">def</span> <span class="nf">color_node</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="n">node_id</span><span class="p">,</span> <span class="n">btw</span> <span class="o">=</span> <span class="n">node</span>
    <span class="n">rgba</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="p">.</span><span class="n">colors</span><span class="p">.</span><span class="nf">to_hex</span><span class="p">(</span><span class="nf">colormap</span><span class="p">(</span><span class="nf">norm</span><span class="p">(</span><span class="n">btw</span><span class="p">)),</span> <span class="n">keep_alpha</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="sh">"</span><span class="s">color</span><span class="sh">"</span><span class="p">:</span> <span class="sa">f</span><span class="sh">"</span><span class="se">\"</span><span class="si">{</span><span class="n">rgba</span><span class="si">}</span><span class="se">\"</span><span class="sh">"</span><span class="p">,</span>
        <span class="sh">"</span><span class="s">fillcolor</span><span class="sh">"</span><span class="p">:</span> <span class="sa">f</span><span class="sh">"</span><span class="se">\"</span><span class="si">{</span><span class="n">rgba</span><span class="si">}</span><span class="se">\"</span><span class="sh">"</span><span class="p">,</span>
        <span class="sh">"</span><span class="s">style</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">filled</span><span class="sh">"</span><span class="p">,</span>
        <span class="sh">"</span><span class="s">fontcolor</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">white</span><span class="sh">"</span><span class="p">,</span>
        <span class="sh">"</span><span class="s">fontsize</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">10.5</span><span class="sh">"</span><span class="p">,</span>
        <span class="sh">"</span><span class="s">label</span><span class="sh">"</span><span class="p">:</span> <span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="n">node_id</span><span class="si">}</span><span class="se">\n</span><span class="s">(</span><span class="si">{</span><span class="n">btw</span><span class="si">:</span><span class="p">.</span><span class="mi">2</span><span class="n">f</span><span class="si">}</span><span class="s">)</span><span class="sh">"</span><span class="p">,</span>
    <span class="p">}</span>

<span class="nf">graphviz_draw</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">node_attr_fn</span><span class="o">=</span><span class="n">color_node</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="sh">"</span><span class="s">neato</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<p><img class="mx-auto d-block mb-2 post-img" src="/assets/img/2023-06-07/betweenness.png"><br></p>

<p>In an unweighted scenario, it appears that nodes 12 and 14 are nodes with the highest betweenness centrality. What would happen if the weight (CNOT error rates) are taken into account?</p>

<h3 id="distance-matrix">Distance Matrix</h3>
<p>To investigate the effect of a weighted graph, the weighted variation of betweenness centrality is needed.<d-cite key="Brandes2008Varia-5940"></d-cite> Instead of implementing the algorithm, one can look into a different but simpler metric - distance matrix to evaluate the quality of a node. In this case, the distance matrix is a two-dimensional symmetric square matrix where the elements $x_ij$ is the shortest path length between the node $i$ and $j$. This is readily available as <code class="language-plaintext highlighter-rouge">floyd_warshall_numpy</code>:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="n">distance_matrix</span> <span class="o">=</span> <span class="n">rx</span><span class="p">.</span><span class="nf">floyd_warshall_numpy</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">weight_fn</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

<span class="n">plt</span><span class="p">.</span><span class="nf">xlabel</span><span class="p">(</span><span class="sh">'</span><span class="s">Node 1</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">ylabel</span><span class="p">(</span><span class="sh">'</span><span class="s">Node 2</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">title</span><span class="p">(</span><span class="sh">'</span><span class="s">Distance matrix</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">imshow</span><span class="p">(</span><span class="n">distance_matrix</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">colorbar</span><span class="p">()</span>
</code></pre></div></div>

<p><img class="mx-auto d-block mb-2 post-img" src="/assets/img/2023-06-07/distance.png"><br></p>

<p>Physically, the values of each element represent the upper bound of the success probability of CNOT entangling operation between a pair of qubits.<d-footnote> This is expressed as a sequence of CNOT gates acting across the qubits that connect the pair of qubits which gives the highest success probability.</d-footnote><d-footnote> In an actual experiment, qubit decoherence resulted in lowered fidelity of the prepared state.</d-footnote> Ideally, the value should be unity. Therefore, a good central qubit should be the one with the highest success probability.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">avg_success</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">mean</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">exp</span><span class="p">(</span><span class="o">-</span><span class="n">distance_matrix</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">avg_success</span><span class="p">)</span>

<span class="n">plt</span><span class="p">.</span><span class="nf">xlabel</span><span class="p">(</span><span class="sh">'</span><span class="s">Node</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">ylabel</span><span class="p">(</span><span class="sh">'</span><span class="s">Average Success CNOT Entangling Probability</span><span class="sh">'</span><span class="p">)</span>
</code></pre></div></div>

<p><img class="mx-auto d-block mb-2 post-img" src="/assets/img/2023-06-07/avg_success.png"><br></p>

<p>When taking into account the edge weight, the poor CNOT performance of node 15 manifests and its surrounding nodes exhibit poor average success probability. Thus, node 14 is now a better candidate for a central qubit.</p>

<h3 id="transversal">Transversal</h3>
<p>The implementation of the transversal algorithm consists of two parts: the <em>search algorithm</em> and the <em>visitor object</em>. As of rustworkx 0.13, three search algorithm with their corresponding visitor object exists:</p>
<ul>
  <li>
<code class="language-plaintext highlighter-rouge">dfs_search</code> / <code class="language-plaintext highlighter-rouge">DFSVisitor</code>
</li>
  <li>
<code class="language-plaintext highlighter-rouge">bfs_search</code> / <code class="language-plaintext highlighter-rouge">BFSVisitor</code>
</li>
  <li>
<code class="language-plaintext highlighter-rouge">dijkstra_search</code> / <code class="language-plaintext highlighter-rouge">DijkstraVisitor</code>
</li>
</ul>

<p>The transversal algorithm of interest for the weighted graph is Dijkstra’s algorithm. The Dijkstra’s algorithm is a single-source shortest-path algorithm that is applicable to both weighted and unweighted graphs. The pseudo-code for the <code class="language-plaintext highlighter-rouge">dijkstra_search</code> algorithm is as follows, which consists of several event points. The visitor object implements the callback functions that are invoked at <a href="https://qiskit.org/documentation/retworkx/apiref/rustworkx.dijkstra_search.html#rustworkx.dijkstra_search" rel="external nofollow noopener" target="_blank">each event point as defined by the pseudo-code</a>. In particular, the event of interest is the <code class="language-plaintext highlighter-rouge">edge_relaxed</code> which is triggered when a shorter path is discovered. With that in mind, a visitor object that records the edges of the shortest path tree with root from the central qubit can be implemented as follows:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">class</span> <span class="nc">TreeEdgesRecorder</span><span class="p">(</span><span class="n">rx</span><span class="p">.</span><span class="n">visit</span><span class="p">.</span><span class="n">DijkstraVisitor</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">edges</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">edge_relaxed</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">edge</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">edges</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>

<span class="n">vis</span> <span class="o">=</span> <span class="nc">TreeEdgesRecorder</span><span class="p">()</span>
<span class="n">rx</span><span class="p">.</span><span class="nf">dijkstra_search</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="p">[</span><span class="n">np</span><span class="p">.</span><span class="nf">argmin</span><span class="p">(</span><span class="n">avg_success</span><span class="p">)],</span> <span class="nb">float</span><span class="p">,</span> <span class="n">vis</span><span class="p">)</span>

<span class="n">colormap</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="p">.</span><span class="n">colormaps</span><span class="p">[</span><span class="sh">"</span><span class="s">magma</span><span class="sh">"</span><span class="p">]</span>
<span class="n">norm</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="p">.</span><span class="n">colors</span><span class="p">.</span><span class="nc">Normalize</span><span class="p">(</span>
    <span class="n">vmin</span><span class="o">=</span><span class="nf">min</span><span class="p">(</span><span class="n">avg_success</span><span class="p">),</span>
    <span class="n">vmax</span><span class="o">=</span><span class="nf">max</span><span class="p">(</span><span class="n">avg_success</span><span class="p">)</span><span class="o">*</span><span class="mf">1.05</span>
<span class="p">)</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">rx</span><span class="p">.</span><span class="nc">PyDiGraph</span><span class="p">()</span>
<span class="n">t</span><span class="p">.</span><span class="nf">extend_from_weighted_edge_list</span><span class="p">(</span><span class="n">vis</span><span class="p">.</span><span class="n">edges</span><span class="p">)</span>
<span class="k">for</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">btw</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">avg_success</span><span class="p">):</span>
    <span class="n">t</span><span class="p">[</span><span class="n">node_id</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">node_id</span><span class="p">,</span> <span class="n">btw</span><span class="p">)</span>

<span class="nf">graphviz_draw</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="sh">'</span><span class="s">dot</span><span class="sh">'</span><span class="p">,</span> <span class="n">node_attr_fn</span><span class="o">=</span><span class="n">color_node</span><span class="p">,</span> <span class="n">graph_attr</span><span class="o">=</span><span class="p">{</span><span class="sh">'</span><span class="s">rankdir</span><span class="sh">'</span><span class="p">:</span> <span class="sh">'</span><span class="s">LR</span><span class="sh">'</span><span class="p">})</span>
</code></pre></div></div>

<p><img class="mx-auto d-block mb-2 post-img" src="/assets/img/2023-06-07/dijkstra.png"><br></p>

<p>The tree obtained from the central root node provides a heuristic approach to hardware-aware mapping of quantum circuits for a whole device entanglement or state preparation (for instance, quantum circuit decomposition of a center-gauge matrix product state).<d-cite key="dborin2021matrix"></d-cite> This technique attempt to minimize the distance between the furthest qubits and the CNOT gate error rate. This concludes the brief demonstration using the hardware coupling map.</p>

<h2 id="map-coloring-and-efficient-quantum-measurement">Map Coloring and Efficient Quantum Measurement</h2>
<p>How can methods for coloring a map lead to a speedup in quantum algorithms such as variational quantum eigensolver (VQE)? This section will explore the connection between these topics and how rustworkx was used within the Qiskit codebase.</p>

<h3 id="four-color-theorem">Four-Color Theorem</h3>

<p>In the October of 1852, Francis Guthrie who was a student in London noticed that only four colors are needed to color the map of the counties of England in such a way that no two countries sharing a common border receive the same color. This then started a chain of letters which sees the birth of the four-color conjecture.</p>

<p>Early proofs of the theorem by Alfred Kempe in 1879 and Peter Guthrie Tait in 1880 turn out to be both fallacious after eleven years each. Eventually, the first correct proof was published in 1976 by Kenneth Appel and Wolfgang Haken. The proof was controversial as it was the first major theorem to be proved using a computer.</p>

<p>On any given map, each region or country on a map can be represented by a node. Two nodes are connected by an edge if the corresponding regions share a common border. Thus, the map coloring is reduced to a planar graph coloring problem. A planar graph is a graph that can be embedded in a plane without any edges crossing. For general graph coloring problems, more colors are needed.</p>

<p><img class="mx-auto d-block mb-2 post-img" src="/assets/img/2023-06-07/apac.png"><br></p>

<p>Enjoy a colored map of the Asia-Pacific!</p>

<h3 id="pauli-grouping">Pauli Grouping</h3>
<p>VQE is a hybrid quantum-classical algorithm designed to find the ground state or energy spectrum of a physical or chemical system. However, obtaining the expectation value of a Hamiltonian requires decomposition into a weighted sum of Pauli string. Each Pauli string needs to be sampled sufficiently many times to obtain a good estimate of the expectation value. Thus, the ability to simultaneously measure commuting Pauli strings, i.e. Pauli grouping is crucial to the performance of VQE.</p>

<p>Starting from a set of Pauli strings <code class="language-plaintext highlighter-rouge">["XX", "YY", "IZ", "ZZ", "ZX"]</code>, the goal is to group the Pauli strings into commuting sets. The algorithm first constructs a graph where the presence of an edge between two nodes indicates their non-commutativity. The graph is then colored such that no two adjacent nodes have the same color. The coloring of the graph then determines the grouping of the Pauli strings.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">qiskit.quantum_info</span> <span class="kn">import</span> <span class="n">PauliList</span>

<span class="n">op</span> <span class="o">=</span> <span class="nc">PauliList</span><span class="p">([</span><span class="sh">"</span><span class="s">XX</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">YY</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">IZ</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">ZZ</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">ZX</span><span class="sh">"</span><span class="p">])</span>
</code></pre></div></div>

<p>Coloring a graph is still an NP-hard problem, but a heuristic algorithm can be employed to obtain good coloring. The greedy algorithm is one such algorithm that is simple and fast. The algorithm starts with an empty coloring and iteratively colors the nodes with the lowest possible color. The algorithm is guaranteed to produce a coloring that is at most one more than the optimal coloring. The algorithm is implemented in rustworkx and can be accessed via <code class="language-plaintext highlighter-rouge">graph_greedy_color</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cmap</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="p">.</span><span class="n">cm</span><span class="p">.</span><span class="nf">get_cmap</span><span class="p">(</span><span class="sh">'</span><span class="s">tab10</span><span class="sh">'</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">node_attr</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="n">rgba</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="p">.</span><span class="n">colors</span><span class="p">.</span><span class="nf">to_hex</span><span class="p">(</span><span class="nf">cmap</span><span class="p">(</span><span class="n">coloring_dict</span><span class="p">[</span><span class="n">node</span><span class="p">]))</span>
    <span class="k">return</span> <span class="p">{</span><span class="sh">'</span><span class="s">label</span><span class="sh">'</span><span class="p">:</span> <span class="nf">str</span><span class="p">(</span><span class="n">op</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="nf">to_label</span><span class="p">()),</span> 
            <span class="sh">'</span><span class="s">shape</span><span class="sh">'</span><span class="p">:</span> <span class="sh">'</span><span class="s">circle</span><span class="sh">'</span><span class="p">,</span> 
            <span class="sh">'</span><span class="s">fillcolor</span><span class="sh">'</span><span class="p">:</span> <span class="sa">f</span><span class="sh">"</span><span class="se">\"</span><span class="si">{</span><span class="n">rgba</span><span class="si">}</span><span class="se">\"</span><span class="sh">"</span><span class="p">,</span> 
            <span class="sh">'</span><span class="s">style</span><span class="sh">'</span><span class="p">:</span> <span class="sh">'</span><span class="s">filled</span><span class="sh">'</span><span class="p">,</span>
            <span class="sh">'</span><span class="s">width</span><span class="sh">'</span><span class="p">:</span> <span class="sh">'</span><span class="s">0.9</span><span class="sh">'</span><span class="p">}</span>


<span class="n">graph</span> <span class="o">=</span> <span class="n">op</span><span class="p">.</span><span class="nf">_create_graph</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="n">coloring_dict</span> <span class="o">=</span> <span class="n">rx</span><span class="p">.</span><span class="nf">graph_greedy_color</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
<span class="nf">graphviz_draw</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">node_attr_fn</span><span class="o">=</span><span class="n">node_attr</span><span class="p">,</span> <span class="n">graph_attr</span><span class="o">=</span><span class="p">{</span><span class="sh">'</span><span class="s">rankdir</span><span class="sh">'</span><span class="p">:</span> <span class="sh">'</span><span class="s">LR</span><span class="sh">'</span><span class="p">})</span>
</code></pre></div></div>

<p><img class="mx-auto d-block mb-2 post-img" src="/assets/img/2023-06-07/pauli-grouping.png"><br></p>

<p>This is the exact implementation of <code class="language-plaintext highlighter-rouge">PauliList.group_commuting</code> under Qiskit. Now, instead of 5 measurements, only 3 measurements are needed to sample all the Pauli strings once. This is a 40% reduction in the number of measurements, demonstrating the importance of Pauli grouping in VQE.</p>

<h2 id="final-remarks">Final Remarks</h2>
<p>Graph theory is a powerful tool that can be applied to many problems in quantum computing and beyond. For performance-critical applications, rustworkx provides a fast and efficient implementation of graph data structure and algorithms. The library is still in its early stage of development and more features will be added in the future. For those interested in contributing or finding out more about the project, please check out the <a href="https://github.com/Qiskit/rustworkx" rel="external nofollow noopener" target="_blank">GitHub repository</a>.</p>

      </d-article>

      <d-appendix>
        <d-footnote-list></d-footnote-list>
        <d-citation-list></d-citation-list>
      </d-appendix>

      <d-bibliography src="/assets/bibliography/2023-06-07.bib"></d-bibliography>
</div>

    <!-- Footer -->    
    <footer class="fixed-bottom">
      <div class="container mt-0">
        © Copyright 2023 Soon  Teh. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>.

      </div>
    </footer>

    <!-- Bootsrap & MDB scripts -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script>

    <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-GF8TKGK3W4"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){ window.dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'G-GF8TKGK3W4');
  </script>
    

<!-- Scrolling Progress Bar -->
<script type="text/javascript">
  /*
   * This JavaScript code has been adapted from the article 
   * https://css-tricks.com/reading-position-indicator/ authored by Pankaj Parashar, 
   * published on the website https://css-tricks.com on the 7th of May, 2014.
   * Couple of changes were made to the original code to make it compatible 
   * with the `al-foio` theme.
   */
  const progressBar = $("#progress");
  /*
   * We set up the bar after all elements are done loading.
   * In some cases, if the images in the page are larger than the intended
   * size they'll have on the page, they'll be resized via CSS to accomodate
   * the desired size. This mistake, however, breaks the computations as the
   * scroll size is computed as soon as the elements finish loading.
   * To account for this, a minimal delay was introduced before computing the
   * values.
   */
  window.onload = function () {
    setTimeout(progressBarSetup, 50);
  };
  /*
   * We set up the bar according to the browser.
   * If the browser supports the progress element we use that.
   * Otherwise, we resize the bar thru CSS styling
   */
  function progressBarSetup() {
    if ("max" in document.createElement("progress")) {
      initializeProgressElement();
      $(document).on("scroll", function() {
        progressBar.attr({ value: getCurrentScrollPosition() });
      });
      $(window).on("resize", initializeProgressElement);
    } else {
      resizeProgressBar();
      $(document).on("scroll", resizeProgressBar);
      $(window).on("resize", resizeProgressBar);
    }
  }
  /*
   * The vertical scroll position is the same as the number of pixels that
   * are hidden from view above the scrollable area. Thus, a value > 0 is
   * how much the user has scrolled from the top
   */
  function getCurrentScrollPosition() {
    return $(window).scrollTop();
  }

  function initializeProgressElement() {
    let navbarHeight = $("#navbar").outerHeight(true);
    $("body").css({ "padding-top": navbarHeight });
    $("progress-container").css({ "padding-top": navbarHeight });
    progressBar.css({ top: navbarHeight });
    progressBar.attr({
      max: getDistanceToScroll(),
      value: getCurrentScrollPosition(),
    });
  }
  /*
   * The offset between the html document height and the browser viewport
   * height will be greater than zero if vertical scroll is possible.
   * This is the distance the user can scroll
   */
  function getDistanceToScroll() {
    return $(document).height() - $(window).height();
  }

  function resizeProgressBar() {
    progressBar.css({ width: getWidthPercentage() + "%" });
  }
  // The scroll ratio equals the percentage to resize the bar
  function getWidthPercentage() {
    return (getCurrentScrollPosition() / getDistanceToScroll()) * 100;
  }
</script>

  
</body>
</html>
