<!DOCTYPE html>
<!-- _layouts/distill.html --><html>
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">    <!-- Metadata, OpenGraph and Schema.org -->
    

    <!-- Standard metadata -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Generating GHZ state on IBM device | Soon  Teh</title>
    <meta name="author" content="Soon  Teh">
    <meta name="description" content="A look into the final lab of IBM Quantum Spring Challenge 2023">


    <!-- Bootstrap & MDB -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous">

    <!-- Bootstrap Table -->
    <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.css">

    <!-- Fonts & Icons -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous">
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons">

    <!-- Code Syntax Highlighting -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light">

    

    <!-- Styles -->
    
    <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;">
    
    <link rel="stylesheet" href="/assets/css/main.css">
    <link rel="canonical" href="https://soon-teh.github.io/blog/2023/quantum-challenge-spring-ghz/">

    <!-- Dark Mode -->
    


    <!-- jQuery -->
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>

    <!-- MathJax -->
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        tags: 'ams'
      }
    };
  </script>
  <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script>
  <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>

    <!-- Distill js -->
    <script src="/assets/js/distillpub/template.v2.js"></script>
    <script src="/assets/js/distillpub/transforms.v2.js"></script>
    <script src="/assets/js/distillpub/overrides.js"></script>
    
    <!-- Page/Post style -->
    <style type="text/css">
      .post-img {
  max-height: 80vh;
  max-width: 100%;
}

    </style>
  </head>

  <body>
<d-front-matter>
    <script async type="text/json">{
      "title": "Generating GHZ state on IBM device",
      "description": "A look into the final lab of IBM Quantum Spring Challenge 2023",
      "published": "May 30, 2023",
      "authors": [
        {
          "author": "Soon Teh",
          "authorURL": "",
          "affiliations": [
            {
              "name": "EQuIP, OIST",
              "url": ""
            }
          ]
        }
        
      ],
      "katex": {
        "delimiters": [
          {
            "left": "$",
            "right": "$",
            "display": false
          },
          {
            "left": "$$",
            "right": "$$",
            "display": true
          }
        ]
      }
    }</script>
  </d-front-matter>

  

    <!-- Header -->
    <header>

      <!-- Nav Bar -->
      <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top">
        <div class="container">
          <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Soon </span>Teh</a>
          <!-- Navbar Toggle -->
          <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar top-bar"></span>
            <span class="icon-bar middle-bar"></span>
            <span class="icon-bar bottom-bar"></span>
          </button>

          <div class="collapse navbar-collapse text-right" id="navbarNav">
            <ul class="navbar-nav ml-auto flex-nowrap">

              <!-- About -->
              <li class="nav-item ">
                <a class="nav-link" href="/">about</a>
              </li>
              
              <!-- Blog -->
              <li class="nav-item active">
                <a class="nav-link" href="/blog/">blog<span class="sr-only">(current)</span></a>
              </li>

              <!-- Other pages -->
              <li class="nav-item ">
                <a class="nav-link" href="/publications/">publications</a>
              </li>
            </ul>
          </div>
        </div>
      </nav>

      <!-- Scrolling Progress Bar -->
      <progress id="progress" value="0">
        <div class="progress-container">
          <span class="progress-bar"></span>
        </div>
      </progress>
    </header>


    <!-- Content -->
    <div class="post distill">

      <d-title>
        <h1>Generating GHZ state on IBM device</h1>
        <p>A look into the final lab of IBM Quantum Spring Challenge 2023</p>
      </d-title>

      <d-byline></d-byline>

      <d-article>
        <d-contents>
          <nav class="l-text figcaption">
          <h3>Contents</h3>
            <div><a href="#ibm-quantum-spring-challenge-2023">IBM Quantum Spring Challenge 2023</a></div>
            <ul>
              <li><a href="#127-qubit-device">127-qubit Device</a></li>
              <li><a href="#ghz-state">GHZ State</a></li>
              
            </ul>
<div><a href="#generating-a-large-ghz-state-with-stabilizers">Generating a Large GHZ State with Stabilizers</a></div>
            <ul>
              <li><a href="#breadth-first-search">Breadth-First Search</a></li>
              <li><a href="#dynamic-circuit">Dynamic Circuit</a></li>
              
            </ul>
<div><a href="#final-remarks">Final Remarks</a></div>
            
          </nav>
        </d-contents>

        <h2 id="ibm-quantum-spring-challenge-2023">IBM Quantum Spring Challenge 2023</h2>
<p><a href="https://research.ibm.com/blog/quantum-challenge-spring-2023" rel="external nofollow noopener" target="_blank">IBM Quantum Spring Challenge</a> was a public event held from May 17 to May 24. This challenge is part of IBM Quantum’s ongoing global education efforts and is free to participate in. The challenge’s goal is to provide participants with a deeper understanding of a specific quantum topic.</p>

<p>This year’s challenge marked the third anniversary of the IBM Quantum Challenge since May 2020. The challenge focuses on <a href="https://quantum-computing.ibm.com/services/programs/docs/runtime/manage/systems/dynamic-circuits/Introduction-To-Dynamic-Circuits" rel="external nofollow noopener" target="_blank">dynamic circuits</a>, which allow for classical processing during the runtime of the circuit. The dynamic circuits were implemented in the challenge to demonstrate error mitigation and quantum teleportation. Participants also have the opportunity to run their program on a 127-qubit device.</p>

<p>Running a quantum algorithm in the current noisy intermediate-scale quantum (NISQ) era remained challenging due to the quality and the limited number of qubits. Thus, the hybrid quantum-classical algorithm was introduced to reduce circuit depth for NISQ devices.<d-footnote>Although in principle, most quantum algorithm (e.g. quantum error correction) does in fact require classical resource for intepreting the results, they are not considered as hybrid.</d-footnote><d-footnote>A hybrid quantum-classical algorithm is defined as an algorithm that requires non-trivial amounts of both quantum and classical computational resources to run, and which cannot be sensibly described, even abstractly, without reference to the classical computation.<d-cite key="Callison_2022"></d-cite></d-footnote> The scaling of this approach is limited by the latency of data exchange between the quantum and classical processors due to the finite coherence time of the qubits. Thus, a new class of hybrid program was proposed in which the classical computation are embedded directly within the quantum program with dynamic circuits, enabling a real-time hybrid algorithm that significantly reduces computational latency.<d-cite key="lubinski2022advancing"></d-cite> Beyond the hybrid quantum-classical algorithm, dynamic circuits also enable mid-circuit measurement for qubit reuse, which offers benefits such as qubit saving, reduced SWAPs and improved fidelity.<d-cite key="hua2023exploiting"></d-cite></p>

<h3 id="127-qubit-device">127-qubit Device</h3>
<p>The <code class="language-plaintext highlighter-rouge">ibm_sherbrooke</code> system assigned to the challenge is a <a href="https://research.ibm.com/blog/eagle-quantum-error-mitigation" rel="external nofollow noopener" target="_blank">127-qubit Eagle processor optimized for error mitigation</a>. Instead of CNOT gates, unidirectional <a href="https://thequantumaviary.blogspot.com/2021/07/how-cross-resonance-gate-works.html" rel="external nofollow noopener" target="_blank">echoed cross-resonance (ECR) gates</a> were implemented due to their simplicity and noise resilience. The coupling map of the device is shown below as a directional graph.</p>

<p><img class="mx-auto d-block mb-2 post-img" src="/assets/img/2023-05-30/directional-coupling.png"><br></p>

<p>The implementation of these unidirectional ECR gates resulted in an interesting CNOT gate transpilation. Since CNOT gate is not a symmetric gate, the transpilation depends on the direction of the CNOT gate. Some transformation identities for assymetric gates are defined in <a href="https://qiskit.org/documentation/stubs/qiskit.transpiler.passes.GateDirection.html" rel="external nofollow noopener" target="_blank">GateDirection</a>.  Meanwhile, CNOT gate is transpiled into ECR and single qubit gate up to a global phase shift.</p>

<p><img class="mx-auto d-block mb-2 post-img" src="/assets/img/2023-05-30/cnot-transpile1.png">
<img class="mx-auto d-block mb-2 post-img" src="/assets/img/2023-05-30/cnot-transpile2.png"></p>

<p>For instance, the unidirectional ECR gate between the qubit $q_{63}$ and $q_{64}$ is implemented in the forward direction from $q_{63}$ to $q_{64}$. The CNOT gate transpilation with control at $q_{63}$ and target at $q_{64}$ resulted in only a depth 5 circuit while depth 7 when reversed.</p>

<h3 id="ghz-state">GHZ State</h3>
<p>The GHZ (Greenberger–Horne–Zeilinger) state is a specific type of quantum entangled state of multiple qubits named after the physicists Daniel Greenberger, Michael Horne, and Anton Zeilinger. The GHZ state is a maximally entangled state of the form</p>

\[\frac{1}{\sqrt{2}}\left(|0\rangle^{\otimes n}+|1\rangle^{\otimes n}\right)\]

<p>where $n$ is the number of qubits. Note that in the case of $n=1$, the equation is reduced to the Bell state. One of the intriguing properties of the GHZ state is that it exhibits perfect correlations. That is, the measurement of one qubit resulted in the same outcome for all other qubits, which is a direct consequence of quantum entanglement.</p>

<h2 id="generating-a-large-ghz-state-with-stabilizers">Generating a Large GHZ State with Stabilizers</h2>
<p>In the final lab of IBM Quantum Spring Challenge 2023, participants were tasked to generate a 54-qubit GHZ state on the 127-qubit real device. Only the even-numbered qubits are used for the GHZ state while the odd-numbered qubits as the stabilzers.</p>

<p><img class="mx-auto d-block mb-2 post-img" src="/assets/img/2023-05-30/odd-even-qubits.png"></p>

<p>The oddness and evenness of the numbers are not to be confused (from the image, red: GHZ qubits; green: stabilizer qubits; and black: unused) with the indexing of the qubit. An unranked optional challenge to generate the GHZ state with the lowest depth can be attempted by motivated participants. Two approaches will be discussed in this post, one with $log(N)$ depth and another of constant depth with respect to the qubit size $N$.</p>

<h3 id="breadth-first-search">Breadth-First Search</h3>

<p>A GHZ state can be constructed by expanding upon the Bell state preparation circuit.</p>

<p><img class="mx-auto d-block mb-2 post-img" src="/assets/img/2023-05-30/ext-bell-circuit.png"></p>

<p>In the example, the Bell state is generated by entangling $q_0$ and $q_4$. Successive CNOT gates are then applied in parallel such that the entangled state grows as $2^d$, where $d$ is the depth of CNOT layers. In other words, the circuit depth scales with $log_2(N)$. However, this approach is limited by the actual connectivity of the device. Thus, an algorithm for generating GHZ state with stabilizers on a real device with limited connectivity is as follows:</p>
<ol>
  <li>Identify a central node with the highest <a href="https://en.wikipedia.org/wiki/Centrality" rel="external nofollow noopener" target="_blank">centrality</a>
</li>
  <li>Implement a breadth-first search (BFS) algorithm from the central node to branch out to all other nodesCNOT gates are applied in order of the branch that leads to the deepest level of the BFS tree to the shallowest</li>
  <li>Disentangle the stabilizer qubits</li>
</ol>

<p>With limited connectivity, the circuit depth then scales with $log_b(N)$, where $0&lt;b\le2$ is the branching factor.</p>

<p><img class="mx-auto d-block mb-2 post-img" src="/assets/img/2023-05-30/bfs-cnot.gif"></p>

<p>For <code class="language-plaintext highlighter-rouge">ibm_sherbrooke</code> device, $q_{62}$ (node in red) was identified as one of the central nodes, and the BFS tree from this central node spans the red edges. The CNOT gates are then applied in the reversed order of depth as shown in the animation to ensure that the gate depth is bounded by the furthest node from the central node. Disentangling the stabilizer is trivial, which requires transversing the tree in reversed direction and applying a CNOT with the odd-numbered qubit as the target. However, the BFS approach is still far from optimal even when all-to-all connectivity is available.</p>

<h3 id="dynamic-circuit">Dynamic Circuit</h3>
<p>In conjunction with this year’s challenge theme on dynamic circuits, an optimal solution with constant scaling can be constructed with dynamic circuits independent of the device size. First, the qubits are sorted into two groups: entangling and parity qubits by their odd-evenness, coinciding with the labeling of GHZ and stabilizer qubits. The algorithm for achieving the GHZ state is described below as:</p>
<ol>
  <li>Apply Hadamard gate to all the entangling qubits</li>
  <li>Apply CNOT gate to the parity qubits using the neighboring entangling qubit as the control</li>
  <li>Measure all the parity qubits</li>
  <li>Apply the parity X gate to the qubits depending on the measurement outcome</li>
</ol>

<p>The following circuit diagram gives an example of a 3 qubit GHZ state with 2 stabilizer qubits</p>

<p><img class="mx-auto d-block mb-2 post-img" src="/assets/img/2023-05-30/ghz-cif.png"></p>

<p>where the parity X gates are drawn explicitly using a soon-to-be deprecated <code class="language-plaintext highlighter-rouge">c_if</code> for clarity. The evolution of the states then follows as</p>

\[\begin{align*}
|00000\rangle  \xrightarrow{\text{Hadamard}} &amp;\, |00000\rangle+|00001\rangle+|00100\rangle+|01101\rangle \\
&amp;\ +|10000\rangle+|10001\rangle+|10100\rangle+|10101\rangle \\

\xrightarrow{\text{CNOT}} &amp;\, |00000\rangle+|00011\rangle+|01110\rangle+|01101\rangle \\
&amp;\ +|11000\rangle+|11011\rangle+|10110\rangle+|10101\rangle \\

= &amp;\, |000\rangle_{\text{ent}}|00\rangle_{\text{parity}}+|001\rangle_{\text{ent}}|01\rangle_{\text{parity}}+|010\rangle_{\text{ent}}|11\rangle_{\text{parity}}\\
&amp;\ +|011\rangle_{\text{ent}}|10\rangle_{\text{parity}}+|100\rangle_{\text{ent}}|10\rangle_{\text{parity}}+|101\rangle_{\text{ent}}|11\rangle_{\text{parity}} \\
&amp;\ +|110\rangle_{\text{ent}}|01\rangle_{\text{parity}}+|111\rangle_{\text{ent}}|00\rangle_{\text{parity}} \\

\xrightarrow{\text{Parity X gate}}|&amp;\, 00000\rangle+|10101\rangle
\end{align*}\]

<p>Parity X gate is defined as a dynamic circuit with the following form</p>

\[\prod_i X_{\text{ent}(i+1)}^{\oplus_i M(i)} X_{\text{partity}(i)}^{M(i)}\]

<p>Here, $M(i)$ is the measurement outcome of the $i$-th parity qubit, and $\oplus_i M(i)$ gives the modulo 2 sum of the parity qubits up til the $i$-th bit. For instance, the parity X gate acting on the $|01110\rangle=|010\rangle_{\text{ent}}|11\rangle_{\text{parity}}$ state is given by</p>

\[X_{\text{ent}(2)} |010\rangle_{\text{ent}} \otimes X_{\text{partity}(2)} X_{\text{partity}(1)}|11\rangle_{\text{parity}} \\
= |000\rangle_{\text{ent}}|00\rangle_{\text{parity}} = |00000\rangle\]

<p>Interestingly, the parity X gate acts at most a single X gate on each qubit, yielding a depth-1 gate upon transpilation. Noting that the parity X gate depends on the parity measurement, a dynamic circuit using the <a href="https://qiskit.org/documentation/stubs/qiskit.circuit.QuantumCircuit.switch.html#qiskit-circuit-quantumcircuit-switch" rel="external nofollow noopener" target="_blank">switch case</a> can be implemented.</p>

<p><img class="mx-auto d-block mb-2 post-img" src="/assets/img/2023-05-30/ghz-switch.png"></p>

<p>The switch/case control flow acts similarly to the switch case in most programming languages and allows for an elegant way of implementing the parity X gate. However, at the time of writing, the backend <a href="https://github.com/Qiskit/qiskit-aer/pull/1778" rel="external nofollow noopener" target="_blank"><code class="language-plaintext highlighter-rouge">Aer 0.12.0</code> does not support <code class="language-plaintext highlighter-rouge">SwitchCaseOp</code></a>. So, the code implementation based on <code class="language-plaintext highlighter-rouge">if_test</code> and <code class="language-plaintext highlighter-rouge">c_if</code> are included for demonstration.</p>

<p>The use of dynamic circuits for GHZ generation reduced the depth required to a fixed value independent of the size, provided one can find a route that visits every node once exists. This is exactly the <a href="https://en.wikipedia.org/wiki/Hamiltonian_path_problem" rel="external nofollow noopener" target="_blank">Hamiltonian path problem</a> which is known to be NP-hard. In general, the Hamiltonian path is not guaranteed to exist. Instead, one can find the longest possible non-overlapping path<d-footnote>The longest path problem is also NP-hard, but it always exists, unlike Hamiltonian path, and a "long enough" path is sufficient in most cases.</d-footnote>, ensuring a maximal number of qubits entangled with the dynamic circuits. The rest of the qubits can then be entangled with usual CNOT gates, imposing a small overhead on the circuit depth. The longest path can be searched using a depth-first search (DFS) algorithm.</p>

<p><img class="mx-auto d-block mb-2 post-img" src="/assets/img/2023-05-30/chain.png"></p>

<p>For <code class="language-plaintext highlighter-rouge">ibm_sherbrooke</code>, one possible solution to the longest path is shown above, tracing the red edges. Uncoupled qubits following the blue edges can then be entangled in the next step with CNOT gates, introducing an overhead of depth 1. A circuit depth of 5 is expected for the dynamic circuit scheme, plus an additional depth for the overhead, bringing to a total of 6. The application of dynamic circuits yields an optimal GHZ state with stabilizer generation with a fixed depth of 5 and a small overhead for non-ideal connectivity.</p>

<h2 id="final-remarks">Final Remarks</h2>
<p>The IBM Quantum Spring Challenge 2023 is an excellent opportunity for the community, beginners and professionals alike to learn about the latest development in quantum computing. Dynamic circuits being one of the new tools introduced in recent years, it would be exciting to see how they can advance the field of quantum computation. So far, this post discusses only the circuit depth reduction without considering the CNOT direction or gate error rate.<d-footnote>The performance should be benchmarked by the fidelity of the GHZ state instead of circuit depth. Although they are correlated, the latter only provides a qualitative figure of merit.</d-footnote> These are left as a practice for interested readers. The implementation of the algorithms discussed for generating large GHZ states can be found <a href="https://github.com/soon-teh/soon-teh.github.io/tree/master/assets/code/lab5-solution-new.ipynb" rel="external nofollow noopener" target="_blank">here</a>.</p>

      </d-article>

      <d-appendix>
        <d-footnote-list></d-footnote-list>
        <d-citation-list></d-citation-list>
      </d-appendix>

      <d-bibliography src="/assets/bibliography/2023-05-30.bib"></d-bibliography>
</div>

    <!-- Footer -->    
    <footer class="fixed-bottom">
      <div class="container mt-0">
        © Copyright 2023 Soon  Teh. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>.

      </div>
    </footer>

    <!-- Bootsrap & MDB scripts -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script>

    <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-GF8TKGK3W4"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){ window.dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'G-GF8TKGK3W4');
  </script>
    

<!-- Scrolling Progress Bar -->
<script type="text/javascript">
  /*
   * This JavaScript code has been adapted from the article 
   * https://css-tricks.com/reading-position-indicator/ authored by Pankaj Parashar, 
   * published on the website https://css-tricks.com on the 7th of May, 2014.
   * Couple of changes were made to the original code to make it compatible 
   * with the `al-foio` theme.
   */
  const progressBar = $("#progress");
  /*
   * We set up the bar after all elements are done loading.
   * In some cases, if the images in the page are larger than the intended
   * size they'll have on the page, they'll be resized via CSS to accomodate
   * the desired size. This mistake, however, breaks the computations as the
   * scroll size is computed as soon as the elements finish loading.
   * To account for this, a minimal delay was introduced before computing the
   * values.
   */
  window.onload = function () {
    setTimeout(progressBarSetup, 50);
  };
  /*
   * We set up the bar according to the browser.
   * If the browser supports the progress element we use that.
   * Otherwise, we resize the bar thru CSS styling
   */
  function progressBarSetup() {
    if ("max" in document.createElement("progress")) {
      initializeProgressElement();
      $(document).on("scroll", function() {
        progressBar.attr({ value: getCurrentScrollPosition() });
      });
      $(window).on("resize", initializeProgressElement);
    } else {
      resizeProgressBar();
      $(document).on("scroll", resizeProgressBar);
      $(window).on("resize", resizeProgressBar);
    }
  }
  /*
   * The vertical scroll position is the same as the number of pixels that
   * are hidden from view above the scrollable area. Thus, a value > 0 is
   * how much the user has scrolled from the top
   */
  function getCurrentScrollPosition() {
    return $(window).scrollTop();
  }

  function initializeProgressElement() {
    let navbarHeight = $("#navbar").outerHeight(true);
    $("body").css({ "padding-top": navbarHeight });
    $("progress-container").css({ "padding-top": navbarHeight });
    progressBar.css({ top: navbarHeight });
    progressBar.attr({
      max: getDistanceToScroll(),
      value: getCurrentScrollPosition(),
    });
  }
  /*
   * The offset between the html document height and the browser viewport
   * height will be greater than zero if vertical scroll is possible.
   * This is the distance the user can scroll
   */
  function getDistanceToScroll() {
    return $(document).height() - $(window).height();
  }

  function resizeProgressBar() {
    progressBar.css({ width: getWidthPercentage() + "%" });
  }
  // The scroll ratio equals the percentage to resize the bar
  function getWidthPercentage() {
    return (getCurrentScrollPosition() / getDistanceToScroll()) * 100;
  }
</script>

  
</body>
</html>
