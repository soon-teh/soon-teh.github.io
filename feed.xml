<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://soon-teh.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://soon-teh.github.io/" rel="alternate" type="text/html" hreflang="en" /><updated>2023-06-22T10:56:53+00:00</updated><id>https://soon-teh.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design.
</subtitle><entry><title type="html">Introduction to rustworkx</title><link href="https://soon-teh.github.io/blog/2023/intro-to-rustworkx/" rel="alternate" type="text/html" title="Introduction to rustworkx" /><published>2023-06-07T00:00:00+00:00</published><updated>2023-06-07T00:00:00+00:00</updated><id>https://soon-teh.github.io/blog/2023/intro-to-rustworkx</id><content type="html" xml:base="https://soon-teh.github.io/blog/2023/intro-to-rustworkx/"><![CDATA[<h2 id="rustworkx">rustworkx</h2>
<p>Qiskit uses <a href="https://github.com/Qiskit/rustworkx"><strong>rustworkx</strong></a> (or formerly <strong>retworkx</strong>), a graph library under the hood. rustworkx was originally conceived to build a faster directed acyclic graph (DAG) to use as the underlying data structure for qiskit-terra’s transpiler. For instance, a Bell state circuit can be represented as a directed graph as follows:</p>

<p><img class="mx-auto d-block mb-2 post-img" src="/assets/img/2023-06-07/bell.png" /><br /></p>

<p>Prior to rustworkx, qiskit uses <a href="https://networkx.org/"><strong>NetworkX</strong></a>. NetworkX’s pure Python implementation leads to a performance bottleneck, and thus rustworkx addressed this by implementing the graph data structures and algorithms in Rust. The performance gain was documented to be 3x to 100x for the same use case compared to NetworkX.<d-cite key="Treinish_2022"></d-cite></p>

<p>Despite basing on NetworkX, rustworkx is not a drop-in replacement, and some of its implementations varies. Key differences and conversion guide can be found <a href="https://qiskit.org/documentation/retworkx/networkx.html">here</a>. This blog post will be looking at some of rustworkx’s features and application of a graph algorithm in quantum computing.</p>

<h2 id="ibm-hardware-coupling-map">IBM Hardware Coupling Map</h2>
<p>This section will use IBM’s hardware coupling map as an example to demonstrate some of rustworkx’s features. The coupling map is a graph that represents the connectivity of the qubits in a quantum device. First, the coupling map is loaded from IBM’s hardware backend:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">qiskit.providers.fake_provider</span> <span class="kn">import</span> <span class="n">FakeAuckland</span>

<span class="n">backend</span> <span class="o">=</span> <span class="nc">FakeAuckland</span><span class="p">()</span>
<span class="n">backend</span><span class="p">.</span><span class="n">coupling_map</span><span class="p">.</span><span class="nf">draw</span><span class="p">()</span>
</code></pre></div></div>
<p><img class="mx-auto d-block mb-2 post-img" src="/assets/img/2023-06-07/auckland-graph.png" /><br /></p>

<p>The circles in the diagram is a <em>node</em> that represents a physical qubit on the device and the arrows are <em>edges</em> that represent the connectivity between the qubits. Each arrow has a <em>weight</em> that is determined by its corresponding CNOT gate error rate.</p>

<p><img class="mx-auto d-block mb-2 post-img" src="/assets/img/2023-06-07/auckland-error.png" /><br /></p>

<p>The standard graph algorithms perform summation across the edges of non-negative weights. Thus, the weights $w$ are defined as the negative log of the CNOT gate success rate:</p>

\[w_{ij}=-\log(1-p_{ij})\]

<p>where $p_{ij}$ is the CNOT gate error rate for the control qubit $i$ and target qubit $j$. Under this convention, smaller weights correspond to higher success probability. For simplicity, the coupling map will be converted to an undirected graph because of the symmetry of the CNOT gate error rate for <code class="language-plaintext highlighter-rouge">ibm_auckland</code>. Special care taking into consideration of the gate asymmetry is needed for hardware such as the <a href="https://research.ibm.com/blog/eagle-quantum-error-mitigation">Eagle processor</a>, which utilizes uni-directional echoed cross-resonance (ECR) gates.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="n">rustworkx</span> <span class="k">as</span> <span class="n">rx</span>

<span class="c1"># extract the two-qubit error rate from the backend
</span><span class="n">two_q_error_map</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">gate</span><span class="p">,</span> <span class="n">prop_dict</span> <span class="ow">in</span> <span class="n">backend</span><span class="p">.</span><span class="n">target</span><span class="p">.</span><span class="nf">items</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">qargs</span><span class="p">,</span> <span class="n">inst_props</span> <span class="ow">in</span> <span class="n">prop_dict</span><span class="p">.</span><span class="nf">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">qargs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">inst_props</span><span class="p">.</span><span class="n">error</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">two_q_error_map</span><span class="p">[</span><span class="n">qargs</span><span class="p">]</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span>
                    <span class="n">two_q_error_map</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">qargs</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">inst_props</span><span class="p">.</span><span class="n">error</span>
                <span class="p">)</span>

<span class="c1"># convert two-qubit error rate to edge weight
</span><span class="n">two_q_suc</span> <span class="o">=</span> <span class="mi">1</span><span class="o">-</span><span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="n">two_q_error_map</span><span class="p">.</span><span class="nf">values</span><span class="p">()))</span>
<span class="n">neg_log_two_q_suc_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="n">two_q_suc</span><span class="p">)</span>
<span class="n">neg_log_two_q_suc</span> <span class="o">=</span> <span class="nf">dict</span><span class="p">(</span><span class="nf">zip</span><span class="p">(</span><span class="n">two_q_error_map</span><span class="p">.</span><span class="nf">keys</span><span class="p">(),</span> <span class="n">neg_log_two_q_suc_val</span><span class="p">))</span>

<span class="c1"># create undirected graph
</span><span class="n">g</span> <span class="o">=</span> <span class="n">rx</span><span class="p">.</span><span class="nc">PyGraph</span><span class="p">(</span><span class="n">multigraph</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="n">g</span><span class="p">.</span><span class="nf">extend_from_weighted_edge_list</span><span class="p">([(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="nf">for </span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">neg_log_two_q_suc</span><span class="p">.</span><span class="nf">items</span><span class="p">()])</span>
</code></pre></div></div>

<p>An empty undirected graph <code class="language-plaintext highlighter-rouge">PyGraph</code> object was first created and populated with the weighted edges using <code class="language-plaintext highlighter-rouge">extend_from_weighted_edge_list</code>. This method will create the nodes and edges if they do not exist. The <code class="language-plaintext highlighter-rouge">multigraph=False</code> argument ensures that the undirected graph has no parallel edges.</p>

<h3 id="visualization">Visualization</h3>
<p>Similar to NetworkX and other popular graph packages, the generated graphs can be visualized using Matplotlib. Under rustworkx, this is done using the <code class="language-plaintext highlighter-rouge">mpl_draw</code> function.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">rustworkx.visualization</span> <span class="kn">import</span> <span class="n">graphviz_draw</span><span class="p">,</span> <span class="n">mpl_draw</span>

<span class="nf">mpl_draw</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
</code></pre></div></div>

<p><img class="mx-auto d-block mb-2 post-img" src="/assets/img/2023-06-07/mpl.png" /><br /></p>

<p>As readers may notice, using Matplotlib to visualize complex graphs can be quite cluttered. Instead, using an alternative method <code class="language-plaintext highlighter-rouge">graphviz_draw</code> with Graphviz to render the graph can improve the clarity and visibility of the components. <a href="https://graphviz.org">Graphviz</a> is a dedicated graph visualization software that supports detailed customization of graph styling.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">graphviz_draw</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="sh">'</span><span class="s">neato</span><span class="sh">'</span><span class="p">)</span>
</code></pre></div></div>

<p><img class="mx-auto d-block mb-2 post-img" src="/assets/img/2023-06-07/neato.png" /><br /></p>

<h3 id="betweenness-centrality">Betweenness Centrality</h3>
<p>Given the coupling map graph, it may be helpful to identify a vital node (qubit) in the graph. Centralities are measures of the relative importance of a node in a graph. One such measure is the betweenness centrality, where for each node $v$ is metric is proportional to the number of shortest paths between all pairs of nodes $\sigma(s,t)$ that passes through $v$:</p>

\[c_B(v)=\sum_{s,t \in V}\frac{\sigma(s,t|v)}{\sigma(s,t)}\]

<p>This is available in rustworkx 0.13.0 as <code class="language-plaintext highlighter-rouge">betweenness_centrality</code> for only unweighted graph:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">matplotlib</span>

<span class="c1"># Assigning data payload to color nodes with graphviz_draw
</span><span class="k">for</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">btw</span> <span class="ow">in</span> <span class="n">c_degree</span><span class="p">.</span><span class="nf">items</span><span class="p">():</span>
    <span class="n">g</span><span class="p">[</span><span class="n">node_id</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">node_id</span><span class="p">,</span> <span class="n">btw</span><span class="p">)</span>

<span class="c1"># Leverage matplotlib for color map
</span><span class="n">colormap</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="p">.</span><span class="n">colormaps</span><span class="p">[</span><span class="sh">"</span><span class="s">magma</span><span class="sh">"</span><span class="p">]</span>
<span class="n">norm</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="p">.</span><span class="n">colors</span><span class="p">.</span><span class="nc">Normalize</span><span class="p">(</span>
    <span class="n">vmin</span><span class="o">=</span><span class="nf">min</span><span class="p">(</span><span class="n">c_degree</span><span class="p">.</span><span class="nf">values</span><span class="p">()),</span>
    <span class="n">vmax</span><span class="o">=</span><span class="nf">max</span><span class="p">(</span><span class="n">c_degree</span><span class="p">.</span><span class="nf">values</span><span class="p">())</span><span class="o">*</span><span class="mf">1.2</span>
<span class="p">)</span>

<span class="k">def</span> <span class="nf">color_node</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="n">node_id</span><span class="p">,</span> <span class="n">btw</span> <span class="o">=</span> <span class="n">node</span>
    <span class="n">rgba</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="p">.</span><span class="n">colors</span><span class="p">.</span><span class="nf">to_hex</span><span class="p">(</span><span class="nf">colormap</span><span class="p">(</span><span class="nf">norm</span><span class="p">(</span><span class="n">btw</span><span class="p">)),</span> <span class="n">keep_alpha</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="sh">"</span><span class="s">color</span><span class="sh">"</span><span class="p">:</span> <span class="sa">f</span><span class="sh">"</span><span class="se">\"</span><span class="si">{</span><span class="n">rgba</span><span class="si">}</span><span class="se">\"</span><span class="sh">"</span><span class="p">,</span>
        <span class="sh">"</span><span class="s">fillcolor</span><span class="sh">"</span><span class="p">:</span> <span class="sa">f</span><span class="sh">"</span><span class="se">\"</span><span class="si">{</span><span class="n">rgba</span><span class="si">}</span><span class="se">\"</span><span class="sh">"</span><span class="p">,</span>
        <span class="sh">"</span><span class="s">style</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">filled</span><span class="sh">"</span><span class="p">,</span>
        <span class="sh">"</span><span class="s">fontcolor</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">white</span><span class="sh">"</span><span class="p">,</span>
        <span class="sh">"</span><span class="s">fontsize</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">10.5</span><span class="sh">"</span><span class="p">,</span>
        <span class="sh">"</span><span class="s">label</span><span class="sh">"</span><span class="p">:</span> <span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="n">node_id</span><span class="si">}</span><span class="se">\n</span><span class="s">(</span><span class="si">{</span><span class="n">btw</span><span class="si">:</span><span class="p">.</span><span class="mi">2</span><span class="n">f</span><span class="si">}</span><span class="s">)</span><span class="sh">"</span><span class="p">,</span>
    <span class="p">}</span>

<span class="nf">graphviz_draw</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">node_attr_fn</span><span class="o">=</span><span class="n">color_node</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="sh">"</span><span class="s">neato</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<p><img class="mx-auto d-block mb-2 post-img" src="/assets/img/2023-06-07/betweenness.png" /><br /></p>

<p>In an unweighted scenario, it appears that nodes 12 and 14 are nodes with the highest betweenness centrality. What would happen if the weight (CNOT error rates) are taken into account?</p>

<h3 id="distance-matrix">Distance Matrix</h3>
<p>To investigate the effect of a weighted graph, the weighted variation of betweenness centrality is needed.<d-cite key="Brandes2008Varia-5940"></d-cite> Instead of implementing the algorithm, one can look into a different but simpler metric - distance matrix to evaluate the quality of a node. In this case, the distance matrix is a two-dimensional symmetric square matrix where the elements $x_ij$ is the shortest path length between the node $i$ and $j$. This is readily available as <code class="language-plaintext highlighter-rouge">floyd_warshall_numpy</code>:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="n">distance_matrix</span> <span class="o">=</span> <span class="n">rx</span><span class="p">.</span><span class="nf">floyd_warshall_numpy</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">weight_fn</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

<span class="n">plt</span><span class="p">.</span><span class="nf">xlabel</span><span class="p">(</span><span class="sh">'</span><span class="s">Node 1</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">ylabel</span><span class="p">(</span><span class="sh">'</span><span class="s">Node 2</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">title</span><span class="p">(</span><span class="sh">'</span><span class="s">Distance matrix</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">imshow</span><span class="p">(</span><span class="n">distance_matrix</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">colorbar</span><span class="p">()</span>
</code></pre></div></div>

<p><img class="mx-auto d-block mb-2 post-img" src="/assets/img/2023-06-07/distance.png" /><br /></p>

<p>Physically, the values of each element represent the upper bound of the success probability of CNOT entangling operation between a pair of qubits.<d-footnote> This is expressed as a sequence of CNOT gates acting across the qubits that connect the pair of qubits which gives the highest success probability.</d-footnote><d-footnote> In an actual experiment, qubit decoherence resulted in lowered fidelity of the prepared state.</d-footnote> Ideally, the value should be unity. Therefore, a good central qubit should be the one with the highest success probability.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">avg_success</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">mean</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">exp</span><span class="p">(</span><span class="o">-</span><span class="n">distance_matrix</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">avg_success</span><span class="p">)</span>

<span class="n">plt</span><span class="p">.</span><span class="nf">xlabel</span><span class="p">(</span><span class="sh">'</span><span class="s">Node</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">ylabel</span><span class="p">(</span><span class="sh">'</span><span class="s">Average Success CNOT Entangling Probability</span><span class="sh">'</span><span class="p">)</span>
</code></pre></div></div>

<p><img class="mx-auto d-block mb-2 post-img" src="/assets/img/2023-06-07/avg_success.png" /><br /></p>

<p>When taking into account the edge weight, the poor CNOT performance of node 15 manifests and its surrounding nodes exhibit poor average success probability. Thus, node 14 is now a better candidate for a central qubit.</p>

<h3 id="transversal">Transversal</h3>
<p>The implementation of the transversal algorithm consists of two parts: the <em>search algorithm</em> and the <em>visitor object</em>. As of rustworkx 0.13, three search algorithm with their corresponding visitor object exists:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">dfs_search</code> / <code class="language-plaintext highlighter-rouge">DFSVisitor</code></li>
  <li><code class="language-plaintext highlighter-rouge">bfs_search</code> / <code class="language-plaintext highlighter-rouge">BFSVisitor</code></li>
  <li><code class="language-plaintext highlighter-rouge">dijkstra_search</code> / <code class="language-plaintext highlighter-rouge">DijkstraVisitor</code></li>
</ul>

<p>The transversal algorithm of interest for the weighted graph is Dijkstra’s algorithm. The Dijkstra’s algorithm is a single-source shortest-path algorithm that is applicable to both weighted and unweighted graphs. The pseudo-code for the <code class="language-plaintext highlighter-rouge">dijkstra_search</code> algorithm is as follows, which consists of several event points. The visitor object implements the callback functions that are invoked at <a href="https://qiskit.org/documentation/retworkx/apiref/rustworkx.dijkstra_search.html#rustworkx.dijkstra_search">each event point as defined by the pseudo-code</a>. In particular, the event of interest is the <code class="language-plaintext highlighter-rouge">edge_relaxed</code> which is triggered when a shorter path is discovered. With that in mind, a visitor object that records the edges of the shortest path tree with root from the central qubit can be implemented as follows:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">class</span> <span class="nc">TreeEdgesRecorder</span><span class="p">(</span><span class="n">rx</span><span class="p">.</span><span class="n">visit</span><span class="p">.</span><span class="n">DijkstraVisitor</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">edges</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">edge_relaxed</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">edge</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">edges</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>

<span class="n">vis</span> <span class="o">=</span> <span class="nc">TreeEdgesRecorder</span><span class="p">()</span>
<span class="n">rx</span><span class="p">.</span><span class="nf">dijkstra_search</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="p">[</span><span class="n">np</span><span class="p">.</span><span class="nf">argmin</span><span class="p">(</span><span class="n">avg_success</span><span class="p">)],</span> <span class="nb">float</span><span class="p">,</span> <span class="n">vis</span><span class="p">)</span>

<span class="n">colormap</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="p">.</span><span class="n">colormaps</span><span class="p">[</span><span class="sh">"</span><span class="s">magma</span><span class="sh">"</span><span class="p">]</span>
<span class="n">norm</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="p">.</span><span class="n">colors</span><span class="p">.</span><span class="nc">Normalize</span><span class="p">(</span>
    <span class="n">vmin</span><span class="o">=</span><span class="nf">min</span><span class="p">(</span><span class="n">avg_success</span><span class="p">),</span>
    <span class="n">vmax</span><span class="o">=</span><span class="nf">max</span><span class="p">(</span><span class="n">avg_success</span><span class="p">)</span><span class="o">*</span><span class="mf">1.05</span>
<span class="p">)</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">rx</span><span class="p">.</span><span class="nc">PyDiGraph</span><span class="p">()</span>
<span class="n">t</span><span class="p">.</span><span class="nf">extend_from_weighted_edge_list</span><span class="p">(</span><span class="n">vis</span><span class="p">.</span><span class="n">edges</span><span class="p">)</span>
<span class="k">for</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">btw</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">avg_success</span><span class="p">):</span>
    <span class="n">t</span><span class="p">[</span><span class="n">node_id</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">node_id</span><span class="p">,</span> <span class="n">btw</span><span class="p">)</span>

<span class="nf">graphviz_draw</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="sh">'</span><span class="s">dot</span><span class="sh">'</span><span class="p">,</span> <span class="n">node_attr_fn</span><span class="o">=</span><span class="n">color_node</span><span class="p">,</span> <span class="n">graph_attr</span><span class="o">=</span><span class="p">{</span><span class="sh">'</span><span class="s">rankdir</span><span class="sh">'</span><span class="p">:</span> <span class="sh">'</span><span class="s">LR</span><span class="sh">'</span><span class="p">})</span>
</code></pre></div></div>

<p><img class="mx-auto d-block mb-2 post-img" src="/assets/img/2023-06-07/dijkstra.png" /><br /></p>

<p>The tree obtained from the central root node provides a heuristic approach to hardware-aware mapping of quantum circuits for a whole device entanglement or state preparation (for instance, quantum circuit decomposition of a center-gauge matrix product state).<d-cite key="dborin2021matrix"></d-cite> This technique attempt to minimize the distance between the furthest qubits and the CNOT gate error rate. This concludes the brief demonstration using the hardware coupling map.</p>

<h2 id="map-coloring-and-efficient-quantum-measurement">Map Coloring and Efficient Quantum Measurement</h2>
<p>How can methods for coloring a map lead to a speedup in quantum algorithms such as variational quantum eigensolver (VQE)? This section will explore the connection between these topics and how rustworkx was used within the Qiskit codebase.</p>

<h3 id="four-color-theorem">Four-Color Theorem</h3>

<p>In the October of 1852, Francis Guthrie who was a student in London noticed that only four colors are needed to color the map of the counties of England in such a way that no two countries sharing a common border receive the same color. This then started a chain of letters which sees the birth of the four-color conjecture.</p>

<p>Early proofs of the theorem by Alfred Kempe in 1879 and Peter Guthrie Tait in 1880 turn out to be both fallacious after eleven years each. Eventually, the first correct proof was published in 1976 by Kenneth Appel and Wolfgang Haken. The proof was initially controversial as it was the first major theorem to be proved using a computer. Appel and Haken’s approach to proving the theorem involved reducing the infinitude of possible maps to 1834 reducible configurations which are then verified by a computer, proving that no counter-example to the four-color conjecture exists.</p>

<p>On any given map, each region or country on a map can be represented by a node. Two nodes are connected by an edge if the corresponding regions share a common border. Thus, the map coloring is reduced to a planar graph coloring problem. A planar graph is a graph that can be embedded in a plane without any edges crossing. For general graph coloring problems, more colors are needed.</p>

<p><img class="mx-auto d-block mb-2 post-img" src="/assets/img/2023-06-07/apac.png" /><br /></p>

<p>Enjoy a colored map of the Asia-Pacific!</p>

<h3 id="pauli-grouping">Pauli Grouping</h3>
<p>VQE is a hybrid quantum-classical algorithm designed to find the ground state or energy spectrum of a physical or chemical system. However, obtaining the expectation value of a Hamiltonian requires decomposition into a weighted sum of Pauli string. Each Pauli string needs to be sampled sufficiently many times to obtain a good estimate of the expectation value. Thus, the ability to simultaneously measure commuting Pauli strings, i.e. Pauli grouping is crucial to the performance of VQE.</p>

<p>Starting from a set of Pauli strings <code class="language-plaintext highlighter-rouge">["XX", "YY", "IZ", "ZZ", "ZX"]</code>, the goal is to group the Pauli strings into commuting sets. The algorithm first constructs a graph where the presence of an edge between two nodes indicates their non-commutativity. The graph is then colored such that no two adjacent nodes have the same color. The coloring of the graph then determines the grouping of the Pauli strings.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">qiskit.quantum_info</span> <span class="kn">import</span> <span class="n">PauliList</span>

<span class="n">op</span> <span class="o">=</span> <span class="nc">PauliList</span><span class="p">([</span><span class="sh">"</span><span class="s">XX</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">YY</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">IZ</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">ZZ</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">ZX</span><span class="sh">"</span><span class="p">])</span>
</code></pre></div></div>

<p>Coloring a graph is still an NP-hard problem, but a heuristic algorithm can be employed to obtain good coloring. The greedy algorithm is one such algorithm that is simple and fast. The algorithm starts with an empty coloring and iteratively colors the nodes with the lowest possible color. The algorithm is guaranteed to produce a coloring that is at most one more than the optimal coloring. The algorithm is implemented in rustworkx and can be accessed via <code class="language-plaintext highlighter-rouge">graph_greedy_color</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cmap</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="p">.</span><span class="n">cm</span><span class="p">.</span><span class="nf">get_cmap</span><span class="p">(</span><span class="sh">'</span><span class="s">tab10</span><span class="sh">'</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">node_attr</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="n">rgba</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="p">.</span><span class="n">colors</span><span class="p">.</span><span class="nf">to_hex</span><span class="p">(</span><span class="nf">cmap</span><span class="p">(</span><span class="n">coloring_dict</span><span class="p">[</span><span class="n">node</span><span class="p">]))</span>
    <span class="k">return</span> <span class="p">{</span><span class="sh">'</span><span class="s">label</span><span class="sh">'</span><span class="p">:</span> <span class="nf">str</span><span class="p">(</span><span class="n">op</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="nf">to_label</span><span class="p">()),</span> 
            <span class="sh">'</span><span class="s">shape</span><span class="sh">'</span><span class="p">:</span> <span class="sh">'</span><span class="s">circle</span><span class="sh">'</span><span class="p">,</span> 
            <span class="sh">'</span><span class="s">fillcolor</span><span class="sh">'</span><span class="p">:</span> <span class="sa">f</span><span class="sh">"</span><span class="se">\"</span><span class="si">{</span><span class="n">rgba</span><span class="si">}</span><span class="se">\"</span><span class="sh">"</span><span class="p">,</span> 
            <span class="sh">'</span><span class="s">style</span><span class="sh">'</span><span class="p">:</span> <span class="sh">'</span><span class="s">filled</span><span class="sh">'</span><span class="p">,</span>
            <span class="sh">'</span><span class="s">width</span><span class="sh">'</span><span class="p">:</span> <span class="sh">'</span><span class="s">0.9</span><span class="sh">'</span><span class="p">}</span>


<span class="n">graph</span> <span class="o">=</span> <span class="n">op</span><span class="p">.</span><span class="nf">_create_graph</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="n">coloring_dict</span> <span class="o">=</span> <span class="n">rx</span><span class="p">.</span><span class="nf">graph_greedy_color</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
<span class="nf">graphviz_draw</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">node_attr_fn</span><span class="o">=</span><span class="n">node_attr</span><span class="p">,</span> <span class="n">graph_attr</span><span class="o">=</span><span class="p">{</span><span class="sh">'</span><span class="s">rankdir</span><span class="sh">'</span><span class="p">:</span> <span class="sh">'</span><span class="s">LR</span><span class="sh">'</span><span class="p">})</span>
</code></pre></div></div>

<p><img class="mx-auto d-block mb-2 post-img" src="/assets/img/2023-06-07/pauli-grouping.png" /><br /></p>

<p>This is the exact implementation of <code class="language-plaintext highlighter-rouge">PauliList.group_commuting</code> under Qiskit. Now, instead of 5 measurements, only 3 measurements are needed to sample all the Pauli strings once. This is a 40% reduction in the number of measurements, demonstrating the importance of Pauli grouping in VQE.</p>

<h2 id="final-remarks">Final Remarks</h2>
<p>Graph theory is a powerful tool that can be applied to many problems in quantum computing and beyond. For performance-critical applications, rustworkx provides a fast and efficient implementation of graph data structure and algorithms. The library is still in its early stage of development and more features will be added in the future. For those interested in contributing or finding out more about the project, please check out the <a href="https://github.com/Qiskit/rustworkx">GitHub repository</a>.</p>]]></content><author><name>Soon Teh</name></author><category term="qiskit" /><category term="rustworkx" /><summary type="html"><![CDATA[With examples and applications in quantum computing]]></summary></entry><entry><title type="html">Generating GHZ state on IBM device</title><link href="https://soon-teh.github.io/blog/2023/quantum-challenge-spring-ghz/" rel="alternate" type="text/html" title="Generating GHZ state on IBM device" /><published>2023-05-30T00:00:00+00:00</published><updated>2023-05-30T00:00:00+00:00</updated><id>https://soon-teh.github.io/blog/2023/quantum-challenge-spring-ghz</id><content type="html" xml:base="https://soon-teh.github.io/blog/2023/quantum-challenge-spring-ghz/"><![CDATA[<h2 id="ibm-quantum-spring-challenge-2023">IBM Quantum Spring Challenge 2023</h2>
<p><a href="https://research.ibm.com/blog/quantum-challenge-spring-2023">IBM Quantum Spring Challenge</a> was a public event held from May 17 to May 24. This challenge is part of IBM Quantum’s ongoing global education efforts and is free to participate in. The challenge’s goal is to provide participants with a deeper understanding of a specific quantum topic.</p>

<p>This year’s challenge marked the third anniversary of the IBM Quantum Challenge since May 2020. The challenge focuses on <a href="https://quantum-computing.ibm.com/services/programs/docs/runtime/manage/systems/dynamic-circuits/Introduction-To-Dynamic-Circuits">dynamic circuits</a>, which allow for classical processing during the runtime of the circuit. The dynamic circuits were implemented in the challenge to demonstrate error mitigation and quantum teleportation. Participants also have the opportunity to run their program on a 127-qubit device.</p>

<p>Running a quantum algorithm in the current noisy intermediate-scale quantum (NISQ) era remained challenging due to the quality and the limited number of qubits. Thus, the hybrid quantum-classical algorithm was introduced to reduce circuit depth for NISQ devices.<d-footnote>Although in principle, most quantum algorithm (e.g. quantum error correction) does in fact require classical resource for intepreting the results, they are not considered as hybrid.</d-footnote><d-footnote>A hybrid quantum-classical algorithm is defined as an algorithm that requires non-trivial amounts of both quantum and classical computational resources to run, and which cannot be sensibly described, even abstractly, without reference to the classical computation.<d-cite key="Callison_2022"></d-cite></d-footnote> The scaling of this approach is limited by the latency of data exchange between the quantum and classical processors due to the finite coherence time of the qubits. Thus, a new class of hybrid program was proposed in which the classical computation are embedded directly within the quantum program with dynamic circuits, enabling a real-time hybrid algorithm that significantly reduces computational latency.<d-cite key="lubinski2022advancing"></d-cite> Beyond the hybrid quantum-classical algorithm, dynamic circuits also enable mid-circuit measurement for qubit reuse, which offers benefits such as qubit saving, reduced SWAPs and improved fidelity.<d-cite key="hua2023exploiting"></d-cite></p>

<h3 id="127-qubit-device">127-qubit Device</h3>
<p>The <code class="language-plaintext highlighter-rouge">ibm_sherbrooke</code> system assigned to the challenge is a <a href="https://research.ibm.com/blog/eagle-quantum-error-mitigation">127-qubit Eagle processor optimized for error mitigation</a>. Instead of CNOT gates, unidirectional <a href="https://thequantumaviary.blogspot.com/2021/07/how-cross-resonance-gate-works.html">echoed cross-resonance (ECR) gates</a> were implemented due to their simplicity and noise resilience. The coupling map of the device is shown below as a directional graph.</p>

<p><img class="mx-auto d-block mb-2 post-img" src="/assets/img/2023-05-30/directional-coupling.png" /><br /></p>

<p>The implementation of these unidirectional ECR gates resulted in an interesting CNOT gate transpilation. Since CNOT gate is not a symmetric gate, the transpilation depends on the direction of the CNOT gate. Some transformation identities for assymetric gates are defined in <a href="https://qiskit.org/documentation/stubs/qiskit.transpiler.passes.GateDirection.html">GateDirection</a>.  Meanwhile, CNOT gate is transpiled into ECR and single qubit gate up to a global phase shift.</p>

<p><img class="mx-auto d-block mb-2 post-img" src="/assets/img/2023-05-30/cnot-transpile1.png" />
<img class="mx-auto d-block mb-2 post-img" src="/assets/img/2023-05-30/cnot-transpile2.png" /></p>

<p>For instance, the unidirectional ECR gate between the qubit $q_{63}$ and $q_{64}$ is implemented in the forward direction from $q_{63}$ to $q_{64}$. The CNOT gate transpilation with control at $q_{63}$ and target at $q_{64}$ resulted in only a depth 5 circuit while depth 7 when reversed.</p>

<h3 id="ghz-state">GHZ State</h3>
<p>The GHZ (Greenberger–Horne–Zeilinger) state is a specific type of quantum entangled state of multiple qubits named after the physicists Daniel Greenberger, Michael Horne, and Anton Zeilinger. The GHZ state is a maximally entangled state of the form</p>

\[\frac{1}{\sqrt{2}}\left(|0\rangle^{\otimes n}+|1\rangle^{\otimes n}\right)\]

<p>where $n$ is the number of qubits. Note that in the case of $n=1$, the equation is reduced to the Bell state. One of the intriguing properties of the GHZ state is that it exhibits perfect correlations. That is, the measurement of one qubit resulted in the same outcome for all other qubits, which is a direct consequence of quantum entanglement.</p>

<h2 id="generating-a-large-ghz-state-with-stabilizers">Generating a Large GHZ State with Stabilizers</h2>
<p>In the final lab of IBM Quantum Spring Challenge 2023, participants were tasked to generate a 54-qubit GHZ state on the 127-qubit real device. Only the even-numbered qubits are used for the GHZ state while the odd-numbered qubits as the stabilzers.</p>

<p><img class="mx-auto d-block mb-2 post-img" src="/assets/img/2023-05-30/odd-even-qubits.png" /></p>

<p>The oddness and evenness of the numbers are not to be confused (from the image, red: GHZ qubits; green: stabilizer qubits; and black: unused) with the indexing of the qubit. An unranked optional challenge to generate the GHZ state with the lowest depth can be attempted by motivated participants. Two approaches will be discussed in this post, one with $log(N)$ depth and another of constant depth with respect to the qubit size $N$.</p>

<h3 id="breadth-first-search">Breadth-First Search</h3>

<p>A GHZ state can be constructed by expanding upon the Bell state preparation circuit.</p>

<p><img class="mx-auto d-block mb-2 post-img" src="/assets/img/2023-05-30/ext-bell-circuit.png" /></p>

<p>In the example, the Bell state is generated by entangling $q_0$ and $q_4$. Successive CNOT gates are then applied in parallel such that the entangled state grows as $2^d$, where $d$ is the depth of CNOT layers. In other words, the circuit depth scales with $log_2(N)$. However, this approach is limited by the actual connectivity of the device. Thus, an algorithm for generating GHZ state with stabilizers on a real device with limited connectivity is as follows:</p>
<ol>
  <li>Identify a central node with the highest <a href="https://en.wikipedia.org/wiki/Centrality">centrality</a></li>
  <li>Implement a breadth-first search (BFS) algorithm from the central node to branch out to all other nodesCNOT gates are applied in order of the branch that leads to the deepest level of the BFS tree to the shallowest</li>
  <li>Disentangle the stabilizer qubits</li>
</ol>

<p>With limited connectivity, the circuit depth then scales with $log_b(N)$, where $0&lt;b\le2$ is the branching factor.</p>

<p><img class="mx-auto d-block mb-2 post-img" src="/assets/img/2023-05-30/bfs-cnot.gif" /></p>

<p>For <code class="language-plaintext highlighter-rouge">ibm_sherbrooke</code> device, $q_{62}$ (node in red) was identified as one of the central nodes, and the BFS tree from this central node spans the red edges. The CNOT gates are then applied in the reversed order of depth as shown in the animation to ensure that the gate depth is bounded by the furthest node from the central node. Disentangling the stabilizer is trivial, which requires transversing the tree in reversed direction and applying a CNOT with the odd-numbered qubit as the target. However, the BFS approach is still far from optimal even when all-to-all connectivity is available.</p>

<h3 id="dynamic-circuit">Dynamic Circuit</h3>
<p>In conjunction with this year’s challenge theme on dynamic circuits, an optimal solution with constant scaling can be constructed with dynamic circuits independent of the device size. First, the qubits are sorted into two groups: entangling and parity qubits by their odd-evenness, coinciding with the labeling of GHZ and stabilizer qubits. The algorithm for achieving the GHZ state is described below as:</p>
<ol>
  <li>Apply Hadamard gate to all the entangling qubits</li>
  <li>Apply CNOT gate to the parity qubits using the neighboring entangling qubit as the control</li>
  <li>Measure all the parity qubits</li>
  <li>Apply the parity X gate to the qubits depending on the measurement outcome</li>
</ol>

<p>The following circuit diagram gives an example of a 3 qubit GHZ state with 2 stabilizer qubits</p>

<p><img class="mx-auto d-block mb-2 post-img" src="/assets/img/2023-05-30/ghz-cif.png" /></p>

<p>where the parity X gates are drawn explicitly using a soon-to-be deprecated <code class="language-plaintext highlighter-rouge">c_if</code> for clarity. The evolution of the states then follows as</p>

\[\begin{align*}
|00000\rangle &amp;\, \xrightarrow{\text{Hadamard}} &amp;\, |00000\rangle+|00001\rangle+|00100\rangle+|01101\rangle \\
&amp;\ +|10000\rangle+|10001\rangle+|10100\rangle+|10101\rangle \\

&amp; \xrightarrow{\text{CNOT}} &amp;\, |00000\rangle+|00011\rangle+|01110\rangle+|01101\rangle \\
&amp;\ +|11000\rangle+|11011\rangle+|10110\rangle+|10101\rangle \\

&amp; = &amp;\, |000\rangle_{\text{ent}}|00\rangle_{\text{parity}}+|001\rangle_{\text{ent}}|01\rangle_{\text{parity}}+|010\rangle_{\text{ent}}|11\rangle_{\text{parity}}\\
&amp;\ +|011\rangle_{\text{ent}}|10\rangle_{\text{parity}}+|100\rangle_{\text{ent}}|10\rangle_{\text{parity}}+|101\rangle_{\text{ent}}|11\rangle_{\text{parity}} \\
&amp;\ +|110\rangle_{\text{ent}}|01\rangle_{\text{parity}}+|111\rangle_{\text{ent}}|00\rangle_{\text{parity}} \\

&amp; \xrightarrow{\text{Parity X gate}}|&amp;\, 00000\rangle+|10101\rangle
\end{align*}\]

<p>Parity X gate is defined as a dynamic circuit with the following form</p>

\[\prod_i X_{\text{ent}(i+1)}^{\oplus_i M(i)} X_{\text{partity}(i)}^{M(i)}\]

<p>Here, $M(i)$ is the measurement outcome of the $i$-th parity qubit, and $\oplus_i M(i)$ gives the modulo 2 sum of the parity qubits up til the $i$-th bit. For instance, the parity X gate acting on the $|01110\rangle=|010\rangle_{\text{ent}}|11\rangle_{\text{parity}}$ state is given by</p>

\[X_{\text{ent}(2)} |010\rangle_{\text{ent}} \otimes X_{\text{partity}(2)} X_{\text{partity}(1)}|11\rangle_{\text{parity}} \\
= |000\rangle_{\text{ent}}|00\rangle_{\text{parity}} = |00000\rangle\]

<p>Interestingly, the parity X gate acts at most a single X gate on each qubit, yielding a depth-1 gate upon transpilation. Noting that the parity X gate depends on the parity measurement, a dynamic circuit using the <a href="https://qiskit.org/documentation/stubs/qiskit.circuit.QuantumCircuit.switch.html#qiskit-circuit-quantumcircuit-switch">switch case</a> can be implemented.</p>

<p><img class="mx-auto d-block mb-2 post-img" src="/assets/img/2023-05-30/ghz-switch.png" /></p>

<p>The switch/case control flow acts similarly to the switch case in most programming languages and allows for an elegant way of implementing the parity X gate. However, at the time of writing, the backend <a href="https://github.com/Qiskit/qiskit-aer/pull/1778"><code class="language-plaintext highlighter-rouge">Aer 0.12.0</code> does not support <code class="language-plaintext highlighter-rouge">SwitchCaseOp</code></a>. So, the code implementation based on <code class="language-plaintext highlighter-rouge">if_test</code> and <code class="language-plaintext highlighter-rouge">c_if</code> are included for demonstration.</p>

<p>The use of dynamic circuits for GHZ generation reduced the depth required to a fixed value independent of the size, provided one can find a route that visits every node once exists. This is exactly the <a href="https://en.wikipedia.org/wiki/Hamiltonian_path_problem">Hamiltonian path problem</a> which is known to be NP-hard. In general, the Hamiltonian path is not guaranteed to exist. Instead, one can find the longest possible non-overlapping path<d-footnote>The longest path problem is also NP-hard, but it always exists, unlike Hamiltonian path, and a "long enough" path is sufficient in most cases.</d-footnote>, ensuring a maximal number of qubits entangled with the dynamic circuits. The rest of the qubits can then be entangled with usual CNOT gates, imposing a small overhead on the circuit depth. The longest path can be searched using a depth-first search (DFS) algorithm.</p>

<p><img class="mx-auto d-block mb-2 post-img" src="/assets/img/2023-05-30/chain.png" /></p>

<p>For <code class="language-plaintext highlighter-rouge">ibm_sherbrooke</code>, one possible solution to the longest path is shown above, tracing the red edges. Uncoupled qubits following the blue edges can then be entangled in the next step with CNOT gates, introducing an overhead of depth 1. A circuit depth of 5 is expected for the dynamic circuit scheme, plus an additional depth for the overhead, bringing to a total of 6. The application of dynamic circuits yields an optimal GHZ state with stabilizer generation with a fixed depth of 5 and a small overhead for non-ideal connectivity.</p>

<h2 id="final-remarks">Final Remarks</h2>
<p>The IBM Quantum Spring Challenge 2023 is an excellent opportunity for the community, beginners and professionals alike to learn about the latest development in quantum computing. Dynamic circuits being one of the new tools introduced in recent years, it would be exciting to see how they can advance the field of quantum computation. So far, this post discusses only the circuit depth reduction without considering the CNOT direction or gate error rate.<d-footnote>The performance should be benchmarked by the fidelity of the GHZ state instead of circuit depth. Although they are correlated, the latter only provides a qualitative figure of merit.</d-footnote> These are left as a practice for interested readers. The implementation of the algorithms discussed for generating large GHZ states can be found <a href="https://github.com/soon-teh/soon-teh.github.io/tree/master/assets/code/lab5-solution-new.ipynb">here</a>.</p>]]></content><author><name>Soon Teh</name></author><category term="qiskit" /><category term="quantum-challenge" /><summary type="html"><![CDATA[A look into the final lab of IBM Quantum Spring Challenge 2023]]></summary></entry></feed>