<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://soon-teh.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://soon-teh.github.io/" rel="alternate" type="text/html" hreflang="en" /><updated>2023-06-14T21:18:28+00:00</updated><id>https://soon-teh.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design.
</subtitle><entry><title type="html">Introduction to rustworkx</title><link href="https://soon-teh.github.io/blog/2023/intro-to-rustworkx/" rel="alternate" type="text/html" title="Introduction to rustworkx" /><published>2023-06-07T00:00:00+00:00</published><updated>2023-06-07T00:00:00+00:00</updated><id>https://soon-teh.github.io/blog/2023/intro-to-rustworkx</id><content type="html" xml:base="https://soon-teh.github.io/blog/2023/intro-to-rustworkx/"><![CDATA[<h2 id="rustworkx">rustworkx</h2>
<p>Qiskit uses <a href="https://github.com/Qiskit/rustworkx"><strong>rustworkx</strong></a> (or formerly <strong>retworkx</strong>), a graph library under the hood. rustworkx was originally conceived to build a faster directed acyclic graph (DAG) to use as the underlying data structure for qiskit-terra’s transpiler. For instance, a Bell state circuit can be represented as a directed graph as follows:</p>

<p><img class="mx-auto d-block mb-2 post-img" src="/assets/img/2023-06-07/bell.png" /><br /></p>

<p>Prior to rustworkx, qiskit uses <a href="https://networkx.org/"><strong>NetworkX</strong></a>. NetworkX’s pure Python implementation leads to a performance bottleneck, and thus rustworkx addressed this by implemnting the graph data structures and algorithms in Rust. The performance gain was documented to be 3x to 100x for the same use case compared to NetworkX.<d-cite key="Treinish_2022"></d-cite></p>

<p>Despite basing on NetworkX, rustworkx is not a drop-in replacement, and some of its implementation varies. Key differences and conversion guide can be found <a href="https://qiskit.org/documentation/retworkx/networkx.html">here</a>. This blog post will be looking at some of rustworkx’s features and application of a graph algorithm in quantum computing.</p>

<h2 id="ibm-hardware-coupling-map">IBM Hardware Coupling Map</h2>
<p>This section will use IBM’s hardware coupling map as an example to demonstrate some of rustworkx’s features. The coupling map is a graph that represents the connectivity of the qubits in a quantum device. First, the coupling map is loaded from IBM’s hardware backend:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">qiskit.providers.fake_provider</span> <span class="kn">import</span> <span class="n">FakeAuckland</span>
<span class="kn">from</span> <span class="n">qiskit.visualization</span> <span class="kn">import</span> <span class="n">plot_gate_map</span><span class="p">,</span> <span class="n">plot_error_map</span>

<span class="n">backend</span> <span class="o">=</span> <span class="nc">FakeAuckland</span><span class="p">()</span>
<span class="n">backend</span><span class="p">.</span><span class="n">coupling_map</span><span class="p">.</span><span class="nf">draw</span><span class="p">()</span>
</code></pre></div></div>
<p><img class="mx-auto d-block mb-2 post-img" src="/assets/img/2023-06-07/auckland-graph.png" /><br /></p>

<p>The circles in the diagram is a <em>node</em> that represents a physical qubit on the device and the arrows are <em>edges</em> that represent the connectivity between the qubits. Each arrow has a <em>weight</em> that is determined by its corresponding CNOT gate error rate.</p>

<p><img class="mx-auto d-block mb-2 post-img" src="/assets/img/2023-06-07/auckland-error.png" /><br /></p>

<p>The standard graph algorithms perform summation across the edges of non-negative weights. Thus, the weights, $w$ are defined as the negative log of the CNOT gate success rate:
\(w_{ij}=-\log(1-p_{ij})\)
where $p_{ij}$ is the CNOT gate error rate for the control qubit $i$ and target qubit $j$. Under this convention, smaller weights corresponds to higher success probability. For simplicity, the coupling map will be converted to a undirected graph because of the symmetry of the CNOT gate error rate for <code class="language-plaintext highlighter-rouge">ibm_auckland</code>. Special care taking into consideration of the gate asymmetry is needed for hardware such as the <a href="https://research.ibm.com/blog/eagle-quantum-error-mitigation">Eagle processor</a>, which utilizes uni-directional echoed cross-resonance (ECR) gates.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="n">rustworkx</span> <span class="k">as</span> <span class="n">rx</span>

<span class="n">two_q_error_map</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">gate</span><span class="p">,</span> <span class="n">prop_dict</span> <span class="ow">in</span> <span class="n">backend</span><span class="p">.</span><span class="n">target</span><span class="p">.</span><span class="nf">items</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">prop_dict</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="bp">None</span> <span class="ow">in</span> <span class="n">prop_dict</span><span class="p">:</span>
        <span class="k">continue</span>
    <span class="k">for</span> <span class="n">qargs</span><span class="p">,</span> <span class="n">inst_props</span> <span class="ow">in</span> <span class="n">prop_dict</span><span class="p">.</span><span class="nf">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">inst_props</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">qargs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">inst_props</span><span class="p">.</span><span class="n">error</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">two_q_error_map</span><span class="p">[</span><span class="n">qargs</span><span class="p">]</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span>
                    <span class="n">two_q_error_map</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">qargs</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">inst_props</span><span class="p">.</span><span class="n">error</span>
                <span class="p">)</span>

<span class="c1"># using negative log success probability as weight
# log allows the product of success rate to be treated as simple sum as per the conventional graph treatment
</span><span class="n">two_q_suc</span> <span class="o">=</span> <span class="mi">1</span><span class="o">-</span><span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="n">two_q_error_map</span><span class="p">.</span><span class="nf">values</span><span class="p">()))</span>
<span class="n">neg_log_two_q_suc_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="n">two_q_suc</span><span class="p">)</span>
<span class="n">neg_log_two_q_suc</span> <span class="o">=</span> <span class="nf">dict</span><span class="p">(</span><span class="nf">zip</span><span class="p">(</span><span class="n">two_q_error_map</span><span class="p">.</span><span class="nf">keys</span><span class="p">(),</span> <span class="n">neg_log_two_q_suc_val</span><span class="p">))</span>

<span class="n">g</span> <span class="o">=</span> <span class="n">rx</span><span class="p">.</span><span class="nc">PyGraph</span><span class="p">()</span>
<span class="n">g</span><span class="p">.</span><span class="nf">extend_from_weighted_edge_list</span><span class="p">([(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="nf">for </span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">neg_log_two_q_suc</span><span class="p">.</span><span class="nf">items</span><span class="p">()])</span>
</code></pre></div></div>

<p>An empty undirected graph <code class="language-plaintext highlighter-rouge">PyGraph</code> object was first created and populated with the weighted edges using <code class="language-plaintext highlighter-rouge">extend_from_weighted_edge_list</code>. This method will create the nodes and edges if they do not exist.</p>

<h3 id="centrality">Centrality</h3>

<h3 id="transversal">Transversal</h3>

<h3 id="mean-spanning-tree">Mean Spanning Tree</h3>

<h2 id="map-coloring-efficient-measurement-and-chemical-structure">Map Coloring, Efficient Measurement and Chemical Structure</h2>

<p><img class="mx-auto d-block mb-2 post-img" src="/assets/img/2023-06-07/apac.png" /><br /></p>

<h3 id="4-color-theorem">4 Color Theorem</h3>

<h3 id="pauli-grouping">Pauli Grouping</h3>
<p><img class="mx-auto d-block mb-2 post-img" src="/assets/img/2023-06-07/apac.png" /><br /></p>

<h3 id="variational-quantum-eigensolver">Variational Quantum Eigensolver</h3>

<h2 id="final-remarks">Final Remarks</h2>]]></content><author><name>Soon Teh</name></author><category term="qiskit" /><category term="rustworkx" /><summary type="html"><![CDATA[With examples on IBM quantum devices]]></summary></entry><entry><title type="html">Generating GHZ state on IBM device</title><link href="https://soon-teh.github.io/blog/2023/quantum-challenge-spring-ghz/" rel="alternate" type="text/html" title="Generating GHZ state on IBM device" /><published>2023-05-30T00:00:00+00:00</published><updated>2023-05-30T00:00:00+00:00</updated><id>https://soon-teh.github.io/blog/2023/quantum-challenge-spring-ghz</id><content type="html" xml:base="https://soon-teh.github.io/blog/2023/quantum-challenge-spring-ghz/"><![CDATA[<h2 id="ibm-quantum-spring-challenge-2023">IBM Quantum Spring Challenge 2023</h2>
<p><a href="https://research.ibm.com/blog/quantum-challenge-spring-2023">IBM Quantum Spring Challenge</a> was a public event held from May 17 to May 24. This challenge is part of IBM Quantum’s ongoing global education efforts and is free to participate in. The challenge’s goal is to provide participants with a deeper understanding of a specific quantum topic.</p>

<p>This year’s challenge marked the third anniversary of the IBM Quantum Challenge since May 2020. The challenge focuses on <a href="https://quantum-computing.ibm.com/services/programs/docs/runtime/manage/systems/dynamic-circuits/Introduction-To-Dynamic-Circuits">dynamic circuits</a>, which allow for classical processing during the runtime of the circuit. The dynamic circuits were implemented in the challenge to demonstrate error mitigation and quantum teleportation. Participants also have the opportunity to run their program on a 127-qubit device.</p>

<p>Running a quantum algorithm in the current noisy intermediate-scale quantum (NISQ) era remained challenging due to the quality and the limited number of qubits. Thus, the hybrid quantum-classical algorithm was introduced to reduce circuit depth for NISQ devices.<d-footnote>Although in principle, most quantum algorithm (e.g. quantum error correction) does in fact require classical resource for intepreting the results, they are not considered as hybrid.</d-footnote><d-footnote>A hybrid quantum-classical algorithm is defined as an algorithm that requires non-trivial amounts of both quantum and classical computational resources to run, and which cannot be sensibly described, even abstractly, without reference to the classical computation.<d-cite key="Callison_2022"></d-cite></d-footnote> The scaling of this approach is limited by the latency of data exchange between the quantum and classical processors due to the finite coherence time of the qubits. Thus, a new class of hybrid program was proposed in which the classical computation are embedded directly within the quantum program with dynamic circuits, enabling a real-time hybrid algorithm that significantly reduces computational latency.<d-cite key="lubinski2022advancing"></d-cite> Beyond the hybrid quantum-classical algorithm, dynamic circuits also enable mid-circuit measurement for qubit reuse, which offers benefits such as qubit saving, reduced SWAPs and improved fidelity.<d-cite key="hua2023exploiting"></d-cite></p>

<h3 id="127-qubit-device">127-qubit Device</h3>
<p>The <code class="language-plaintext highlighter-rouge">ibm_sherbrooke</code> system assigned to the challenge is a <a href="https://research.ibm.com/blog/eagle-quantum-error-mitigation">127-qubit Eagle processor optimized for error mitigation</a>. Instead of CNOT gates, unidirectional <a href="https://thequantumaviary.blogspot.com/2021/07/how-cross-resonance-gate-works.html">echoed cross-resonance (ECR) gates</a> were implemented due to their simplicity and noise resilience. The coupling map of the device is shown below as a directional graph.</p>

<p><img class="mx-auto d-block mb-2 post-img" src="/assets/img/2023-05-30/directional-coupling.png" /><br /></p>

<p>The implementation of these unidirectional ECR gates resulted in an interesting CNOT gate transpilation. Since CNOT gate is not a symmetric gate, the transpilation depends on the direction of the CNOT gate. Some transformation identities for assymetric gates are defined in <a href="https://qiskit.org/documentation/stubs/qiskit.transpiler.passes.GateDirection.html">GateDirection</a>.  Meanwhile, CNOT gate is transpiled into ECR and single qubit gate up to a global phase shift.</p>

<p><img class="mx-auto d-block mb-2 post-img" src="/assets/img/2023-05-30/cnot-transpile1.png" />
<img class="mx-auto d-block mb-2 post-img" src="/assets/img/2023-05-30/cnot-transpile2.png" /></p>

<p>For instance, the unidirectional ECR gate between the qubit $q_{63}$ and $q_{64}$ is implemented in the forward direction from $q_{63}$ to $q_{64}$. The CNOT gate transpilation with control at $q_{63}$ and target at $q_{64}$ resulted in only a depth 5 circuit while depth 7 when reversed.</p>

<h3 id="ghz-state">GHZ State</h3>
<p>The GHZ (Greenberger–Horne–Zeilinger) state is a specific type of quantum entangled state of multiple qubits named after the physicists Daniel Greenberger, Michael Horne, and Anton Zeilinger. The GHZ state is a maximally entangled state of the form</p>

\[\frac{1}{\sqrt{2}}\left(|0\rangle^{\otimes n}+|1\rangle^{\otimes n}\right)\]

<p>where $n$ is the number of qubits. Note that in the case of $n=1$, the equation is reduced to the Bell state. One of the intriguing properties of the GHZ state is that it exhibits perfect correlations. That is, the measurement of one qubit resulted in the same outcome for all other qubits, which is a direct consequence of quantum entanglement.</p>

<h2 id="generating-a-large-ghz-state-with-stabilizers">Generating a Large GHZ State with Stabilizers</h2>
<p>In the final lab of IBM Quantum Spring Challenge 2023, participants were tasked to generate a 54-qubit GHZ state on the 127-qubit real device. Only the even-numbered qubits are used for the GHZ state while the odd-numbered qubits as the stabilzers.</p>

<p><img class="mx-auto d-block mb-2 post-img" src="/assets/img/2023-05-30/odd-even-qubits.png" /></p>

<p>The oddness and evenness of the numbers are not to be confused (from the image, red: GHZ qubits; green: stabilizer qubits; and black: unused) with the indexing of the qubit. An unranked optional challenge to generate the GHZ state with the lowest depth can be attempted by motivated participants. Two approaches will be discussed in this post, one with $log(N)$ depth and another of constant depth with respect to the qubit size $N$.</p>

<h3 id="breadth-first-search">Breadth-First Search</h3>

<p>A GHZ state can be constructed by expanding upon the Bell state preparation circuit.</p>

<p><img class="mx-auto d-block mb-2 post-img" src="/assets/img/2023-05-30/ext-bell-circuit.png" /></p>

<p>In the example, the Bell state is generated by entangling $q_0$ and $q_4$. Successive CNOT gates are then applied in parallel such that the entangled state grows as $2^d$, where $d$ is the depth of CNOT layers. In other words, the circuit depth scales with $log_2(N)$. However, this approach is limited by the actual connectivity of the device. Thus, an algorithm for generating GHZ state with stabilizers on a real device with limited connectivity is as follows:</p>
<ol>
  <li>Identify a central node with the highest <a href="https://en.wikipedia.org/wiki/Centrality">centrality</a></li>
  <li>Implement a breadth-first search (BFS) algorithm from the central node to branch out to all other nodesCNOT gates are applied in order of the branch that leads to the deepest level of the BFS tree to the shallowest</li>
  <li>Disentangle the stabilizer qubits</li>
</ol>

<p>With limited connectivity, the circuit depth then scales with $log_b(N)$, where $0&lt;b\le2$ is the branching factor.</p>

<p><img class="mx-auto d-block mb-2 post-img" src="/assets/img/2023-05-30/bfs-cnot.gif" /></p>

<p>For <code class="language-plaintext highlighter-rouge">ibm_sherbrooke</code> device, $q_{62}$ (node in red) was identified as one of the central nodes, and the BFS tree from this central node spans the red edges. The CNOT gates are then applied in the reversed order of depth as shown in the animation to ensure that the gate depth is bounded by the furthest node from the central node. Disentangling the stabilizer is trivial, which requires transversing the tree in reversed direction and applying a CNOT with the odd-numbered qubit as the target. However, the BFS approach is still far from optimal even when all-to-all connectivity is available.</p>

<h3 id="dynamic-circuit">Dynamic Circuit</h3>
<p>In conjunction with this year’s challenge theme on dynamic circuits, an optimal solution with constant scaling can be constructed with dynamic circuits independent of the device size. First, the qubits are sorted into two groups: entangling and parity qubits by their odd-evenness, coinciding with the labeling of GHZ and stabilizer qubits. The algorithm for achieving the GHZ state is described below as:</p>
<ol>
  <li>Apply Hadamard gate to all the entangling qubits</li>
  <li>Apply CNOT gate to the parity qubits using the neighboring entangling qubit as the control</li>
  <li>Measure all the parity qubits</li>
  <li>Apply the parity X gate to the qubits depending on the measurement outcome</li>
</ol>

<p>The following circuit diagram gives an example of a 3 qubit GHZ state with 2 stabilizer qubits</p>

<p><img class="mx-auto d-block mb-2 post-img" src="/assets/img/2023-05-30/ghz-cif.png" /></p>

<p>where the parity X gates are drawn explicitly using a soon-to-be deprecated <code class="language-plaintext highlighter-rouge">c_if</code> for clarity. The evolution of the states then follows as</p>

\[\begin{align*}
|00000\rangle &amp;\, \xrightarrow{\text{Hadamard}} &amp;\, |00000\rangle+|00001\rangle+|00100\rangle+|01101\rangle \\
&amp;\ +|10000\rangle+|10001\rangle+|10100\rangle+|10101\rangle \\

&amp; \xrightarrow{\text{CNOT}} &amp;\, |00000\rangle+|00011\rangle+|01110\rangle+|01101\rangle \\
&amp;\ +|11000\rangle+|11011\rangle+|10110\rangle+|10101\rangle \\

&amp; = &amp;\, |000\rangle_{\text{ent}}|00\rangle_{\text{parity}}+|001\rangle_{\text{ent}}|01\rangle_{\text{parity}}+|010\rangle_{\text{ent}}|11\rangle_{\text{parity}}\\
&amp;\ +|011\rangle_{\text{ent}}|10\rangle_{\text{parity}}+|100\rangle_{\text{ent}}|10\rangle_{\text{parity}}+|101\rangle_{\text{ent}}|11\rangle_{\text{parity}} \\
&amp;\ +|110\rangle_{\text{ent}}|01\rangle_{\text{parity}}+|111\rangle_{\text{ent}}|00\rangle_{\text{parity}} \\

&amp; \xrightarrow{\text{Parity X gate}}|&amp;\, 00000\rangle+|10101\rangle
\end{align*}\]

<p>Parity X gate is defined as a dynamic circuit with the following form</p>

\[\prod_i X_{\text{ent}(i+1)}^{\oplus_i M(i)} X_{\text{partity}(i)}^{M(i)}\]

<p>Here, $M(i)$ is the measurement outcome of the $i$-th parity qubit, and $\oplus_i M(i)$ gives the modulo 2 sum of the parity qubits up til the $i$-th bit. For instance, the parity X gate acting on the $|01110\rangle=|010\rangle_{\text{ent}}|11\rangle_{\text{parity}}$ state is given by</p>

\[X_{\text{ent}(2)} |010\rangle_{\text{ent}} \otimes X_{\text{partity}(2)} X_{\text{partity}(1)}|11\rangle_{\text{parity}} \\
= |000\rangle_{\text{ent}}|00\rangle_{\text{parity}} = |00000\rangle\]

<p>Interestingly, the parity X gate acts at most a single X gate on each qubit, yielding a depth-1 gate upon transpilation. Noting that the parity X gate depends on the parity measurement, a dynamic circuit using the <a href="https://qiskit.org/documentation/stubs/qiskit.circuit.QuantumCircuit.switch.html#qiskit-circuit-quantumcircuit-switch">switch case</a> can be implemented.</p>

<p><img class="mx-auto d-block mb-2 post-img" src="/assets/img/2023-05-30/ghz-switch.png" /></p>

<p>The switch/case control flow acts similarly to the switch case in most programming languages and allows for an elegant way of implementing the parity X gate. However, at the time of writing, the backend <a href="https://github.com/Qiskit/qiskit-aer/pull/1778"><code class="language-plaintext highlighter-rouge">Aer 0.12.0</code> does not support <code class="language-plaintext highlighter-rouge">SwitchCaseOp</code></a>. So, the code implementation based on <code class="language-plaintext highlighter-rouge">if_test</code> and <code class="language-plaintext highlighter-rouge">c_if</code> are included for demonstration.</p>

<p>The use of dynamic circuits for GHZ generation reduced the depth required to a fixed value independent of the size, provided one can find a route that visits every node once exists. This is exactly the <a href="https://en.wikipedia.org/wiki/Hamiltonian_path_problem">Hamiltonian path problem</a> which is known to be NP-hard. In general, the Hamiltonian path is not guaranteed to exist. Instead, one can find the longest possible non-overlapping path<d-footnote>The longest path problem is also NP-hard, but it always exists, unlike Hamiltonian path, and a "long enough" path is sufficient in most cases.</d-footnote>, ensuring a maximal number of qubits entangled with the dynamic circuits. The rest of the qubits can then be entangled with usual CNOT gates, imposing a small overhead on the circuit depth. The longest path can be searched using a depth-first search (DFS) algorithm.</p>

<p><img class="mx-auto d-block mb-2 post-img" src="/assets/img/2023-05-30/chain.png" /></p>

<p>For <code class="language-plaintext highlighter-rouge">ibm_sherbrooke</code>, one possible solution to the longest path is shown above, tracing the red edges. Uncoupled qubits following the blue edges can then be entangled in the next step with CNOT gates, introducing an overhead of depth 1. A circuit depth of 5 is expected for the dynamic circuit scheme, plus an additional depth for the overhead, bringing to a total of 6. The application of dynamic circuits yields an optimal GHZ state with stabilizer generation with a fixed depth of 5 and a small overhead for non-ideal connectivity.</p>

<h2 id="final-remarks">Final Remarks</h2>
<p>The IBM Quantum Spring Challenge 2023 is an excellent opportunity for the community, beginners and professionals alike to learn about the latest development in quantum computing. Dynamic circuits being one of the new tools introduced in recent years, it would be exciting to see how they can advance the field of quantum computation. So far, this post discusses only the circuit depth reduction without considering the CNOT direction or gate error rate.<d-footnote>The performance should be benchmarked by the fidelity of the GHZ state instead of circuit depth. Although they are correlated, the latter only provides a qualitative figure of merit.</d-footnote> These are left as a practice for interested readers. The implementation of the algorithms discussed for generating large GHZ states can be found <a href="">here</a>.</p>]]></content><author><name>Soon Teh</name></author><category term="qiskit" /><category term="quantum-challenge" /><summary type="html"><![CDATA[A look into the final lab of IBM Quantum Spring Challenge 2023]]></summary></entry></feed>